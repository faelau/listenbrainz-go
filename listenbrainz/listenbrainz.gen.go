// Package listenbrainz provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package listenbrainz

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	ApiKeyAuthScopes = "ApiKeyAuth.Scopes"
)

// Defines values for AllowedRatings.
const (
	BadRecommendation AllowedRatings = "bad_recommendation"
	Dislike           AllowedRatings = "dislike"
	Hate              AllowedRatings = "hate"
	Like              AllowedRatings = "like"
	Love              AllowedRatings = "love"
)

// Defines values for AllowedStatisticsRange.
const (
	AllTime    AllowedStatisticsRange = "all_time"
	HalfYearly AllowedStatisticsRange = "half_yearly"
	Month      AllowedStatisticsRange = "month"
	Quarter    AllowedStatisticsRange = "quarter"
	ThisMonth  AllowedStatisticsRange = "this_month"
	ThisWeek   AllowedStatisticsRange = "this_week"
	ThisYear   AllowedStatisticsRange = "this_year"
	Week       AllowedStatisticsRange = "week"
	Year       AllowedStatisticsRange = "year"
)

// Defines values for CoverTypes.
const (
	DesignerTop10    CoverTypes = "designer-top-10"
	DesignerTop5     CoverTypes = "designer-top-5"
	GridStats        CoverTypes = "grid-stats"
	GridStatsSpecial CoverTypes = "grid-stats-special"
	LpsOnTheFloor    CoverTypes = "lps-on-the-floor"
)

// Defines values for ListenType.
const (
	Import     ListenType = "import"
	PlayingNow ListenType = "playing_now"
	Single     ListenType = "single"
)

// Defines values for Mode.
const (
	Easy   Mode = "easy"
	Hard   Mode = "hard"
	Medium Mode = "medium"
)

// Defines values for Operator.
const (
	AND Operator = "AND"
	OR  Operator = "OR"
)

// Defines values for YearInMusicImage.
const (
	Albums            YearInMusicImage = "albums"
	Artists           YearInMusicImage = "artists"
	DiscoveryPlaylist YearInMusicImage = "discovery-playlist"
	MissedPlaylist    YearInMusicImage = "missed-playlist"
	Overview          YearInMusicImage = "overview"
	Stats             YearInMusicImage = "stats"
	Tracks            YearInMusicImage = "tracks"
)

// Defines values for CreateCoverArtGridBackground.
const (
	Black       CreateCoverArtGridBackground = "black"
	Transparent CreateCoverArtGridBackground = "transparent"
	White       CreateCoverArtGridBackground = "white"
)

// Defines values for FreshReleasesParamsSort.
const (
	ArtistCreditName FreshReleasesParamsSort = "artist_credit_name"
	ReleaseDate      FreshReleasesParamsSort = "release_date"
	ReleaseName      FreshReleasesParamsSort = "release_name"
)

// AllowedRatings defines model for AllowedRatings.
type AllowedRatings string

// AllowedStatisticsRange defines model for AllowedStatisticsRange.
type AllowedStatisticsRange string

// CoverTypes defines model for CoverTypes.
type CoverTypes string

// ListenType defines model for ListenType.
type ListenType string

// Mode mode is the LB radio mode to be used for this query
type Mode string

// Operator defines model for Operator.
type Operator string

// YearInMusicImage defines model for YearInMusicImage.
type YearInMusicImage string

// AdditionalInfo defines model for additionalInfo.
type AdditionalInfo struct {
	Albumartist             *string               `json:"albumartist,omitempty"`
	ArtistMbids             *[]openapi_types.UUID `json:"artist_mbids,omitempty"`
	ArtistNames             *[]string             `json:"artist_names,omitempty"`
	Comment                 *string               `json:"comment,omitempty"`
	Date                    *string               `json:"date,omitempty"`
	Discnumber              *int                  `json:"discnumber,omitempty"`
	Duration                *int                  `json:"duration,omitempty"`
	DurationMs              *int                  `json:"duration_ms,omitempty"`
	Genre                   *string               `json:"genre,omitempty"`
	Isrc                    *string               `json:"isrc,omitempty"`
	ListeningFrom           *string               `json:"listening_from,omitempty"`
	MediaPlayer             *string               `json:"media_player,omitempty"`
	MediaPlayerVersion      *string               `json:"media_player_version,omitempty"`
	MusicService            *string               `json:"music_service,omitempty"`
	MusicServiceName        *string               `json:"music_service_name,omitempty"`
	OriginUrl               *string               `json:"origin_url,omitempty"`
	RecordingMbid           *openapi_types.UUID   `json:"recording_mbid,omitempty"`
	RecordingMsid           *openapi_types.UUID   `json:"recording_msid,omitempty"`
	ReleaseArtistName       *string               `json:"release_artist_name,omitempty"`
	ReleaseArtistNames      *[]string             `json:"release_artist_names,omitempty"`
	ReleaseGroupMbid        *openapi_types.UUID   `json:"release_group_mbid,omitempty"`
	ReleaseMbid             *openapi_types.UUID   `json:"release_mbid,omitempty"`
	SpotifyAlbumArtistIds   *[]string             `json:"spotify_album_artist_ids,omitempty"`
	SpotifyAlbumId          *string               `json:"spotify_album_id,omitempty"`
	SpotifyArtistIds        *[]string             `json:"spotify_artist_ids,omitempty"`
	SpotifyId               *string               `json:"spotify_id,omitempty"`
	SubmissionClient        *string               `json:"submission_client,omitempty"`
	SubmissionClientVersion *string               `json:"submission_client_version,omitempty"`
	Tags                    *[]string             `json:"tags,omitempty"`
	TrackNumber             *string               `json:"trackNumber,omitempty"`
	TrackMbid               *openapi_types.UUID   `json:"track_mbid,omitempty"`
	Tracknumber             *int                  `json:"tracknumber,omitempty"`
	WorkMbids               *[]openapi_types.UUID `json:"work_mbids,omitempty"`
	YoutubeId               *string               `json:"youtube_id,omitempty"`
	AdditionalProperties    map[string]string     `json:"-"`
}

// ArtistMapForUser defines model for artistMapForUser.
type ArtistMapForUser struct {
	Payload ArtistMapForUserPayload `json:"payload"`
}

// ArtistMapForUserPayload defines model for artistMapForUser_payload.
type ArtistMapForUserPayload struct {
	ArtistMap   []ArtistMapForUserPayloadArtistMapInner `json:"artist_map"`
	FromTs      int                                     `json:"from_ts"`
	LastUpdated int                                     `json:"last_updated"`
	Range       string                                  `json:"range"`
	ToTs        int                                     `json:"to_ts"`
	UserId      string                                  `json:"user_id"`
}

// ArtistMapForUserPayloadArtistMapInner defines model for artistMapForUser_payload_artist_map_inner.
type ArtistMapForUserPayloadArtistMapInner struct {
	ArtistCount *int                                    `json:"artist_count,omitempty"`
	Artists     *[]TopArtistsForUserPayloadArtistsInner `json:"artists,omitempty"`
	Country     *string                                 `json:"country,omitempty"`
	ListenCount *int                                    `json:"listen_count,omitempty"`
}

// ArtistMetadata defines model for artistMetadata.
type ArtistMetadata struct {
	Area       *string             `json:"area,omitempty"`
	ArtistMbid *openapi_types.UUID `json:"artist_mbid,omitempty"`
	BeginYear  *int                `json:"begin_year,omitempty"`
	Gender     *string             `json:"gender,omitempty"`
	Mbid       *string             `json:"mbid,omitempty"`
	Name       *string             `json:"name,omitempty"`
	Rels       *Rels1              `json:"rels,omitempty"`
	Tag        *ArtistMetadataTag  `json:"tag,omitempty"`
	Type       *string             `json:"type,omitempty"`
}

// ArtistMetadataTag defines model for artistMetadata_tag.
type ArtistMetadataTag struct {
	Artist []TopReleaseGroupsForArtistInnerTagArtistInner `json:"artist"`
}

// Artist200ResponseInner defines model for artist_200_response_inner.
type Artist200ResponseInner struct {
	ArtistMbid       *openapi_types.UUID `json:"artist_mbid,omitempty"`
	TotalListenCount *int                `json:"total_listen_count,omitempty"`
	TotalUserCount   *int                `json:"total_user_count,omitempty"`
}

// ArtistRequest defines model for artist_request.
type ArtistRequest struct {
	ArtistMbids []openapi_types.UUID `json:"artist_mbids"`
}

// Color defines model for color.
type Color struct {
	Payload ColorPayload `json:"payload"`
}

// ColorPayload defines model for color_payload.
type ColorPayload struct {
	Releases []ColorPayloadReleasesInner `json:"releases"`
}

// ColorPayloadReleasesInner defines model for color_payload_releases_inner.
type ColorPayloadReleasesInner struct {
	ArtistName  *string                                     `json:"artist_name,omitempty"`
	CaaId       *int                                        `json:"caa_id,omitempty"`
	Color       *[]int                                      `json:"color,omitempty"`
	Dist        *int                                        `json:"dist,omitempty"`
	Recordings  *[]ColorPayloadReleasesInnerRecordingsInner `json:"recordings,omitempty"`
	ReleaseMbid *openapi_types.UUID                         `json:"release_mbid,omitempty"`
	ReleaseName *string                                     `json:"release_name,omitempty"`
}

// ColorPayloadReleasesInnerRecordingsInner defines model for color_payload_releases_inner_recordings_inner.
type ColorPayloadReleasesInnerRecordingsInner struct {
	TrackMetadata *ColorPayloadReleasesInnerRecordingsInnerTrackMetadata `json:"track_metadata,omitempty"`
}

// ColorPayloadReleasesInnerRecordingsInnerTrackMetadata defines model for color_payload_releases_inner_recordings_inner_track_metadata.
type ColorPayloadReleasesInnerRecordingsInnerTrackMetadata struct {
	AdditionalInfo ColorPayloadReleasesInnerRecordingsInnerTrackMetadataAdditionalInfo `json:"additional_info"`
	ArtistName     string                                                              `json:"artist_name"`
	ReleaseName    string                                                              `json:"release_name"`
	TrackName      string                                                              `json:"track_name"`
}

// ColorPayloadReleasesInnerRecordingsInnerTrackMetadataAdditionalInfo defines model for color_payload_releases_inner_recordings_inner_track_metadata_additional_info.
type ColorPayloadReleasesInnerRecordingsInnerTrackMetadataAdditionalInfo struct {
	ArtistMbids   []openapi_types.UUID `json:"artist_mbids"`
	RecordingMbid openapi_types.UUID   `json:"recording_mbid"`
	ReleaseMbid   openapi_types.UUID   `json:"release_mbid"`
}

// CreateCoverArtGrid defines model for createCoverArtGrid.
type CreateCoverArtGrid struct {
	// Background The background for the cover art.
	Background CreateCoverArtGridBackground `json:"background"`

	// Dimension The dimension to use for this grid. A grid of dimension 3 has 3 images across and 3 images down, for a total of 9 images.
	Dimension int `json:"dimension"`

	// ImageSize The size of the cover art image.
	ImageSize int `json:"image_size"`

	// ReleaseMbids An ordered list of release_mbids. The images will be loaded and processed in the order that this list is in. The cover art for the release_mbids will be placed on the tiles defined by the tiles parameter.
	ReleaseMbids []openapi_types.UUID `json:"release_mbids"`

	// ShowCaa If cover art is missing and skip-missing is false, then show-caa will determine if a blank square is shown or if the Cover Art Archive missing image is shown.
	ShowCaa bool `json:"show-caa"`

	// SkipMissing If cover art is missing for a given release_mbid, skip it and move on to the next one, if true is passed. If false, the show-caa option will decide what happens.
	SkipMissing bool `json:"skip-missing"`

	// Tiles The tiles paramater is a list of strings that determines the location where cover art images should be placed. Each string is a comma separated list of image cells. A grid of dimension 3 has 9 cells, from 0 in the upper left hand corner, 2 in the upper right hand corner, 6 in the lower left corner and 8 in the lower right corner. Specifying only a single cell will have the image cover that cell exactly. If more than one cell is specified, the image will cover the area defined by the bounding box of all the given cells. These tiles only define bounding box areas - no clipping of images that may fall outside of these tiles will be performed.
	Tiles []string `json:"tiles"`
}

// CreateCoverArtGridBackground The background for the cover art.
type CreateCoverArtGridBackground string

// CreateNotificationRequest defines model for createNotification_request.
type CreateNotificationRequest struct {
	Metadata *CreateNotificationRequestMetadata `json:"metadata,omitempty"`
}

// CreateNotificationRequestMetadata defines model for createNotification_request_metadata.
type CreateNotificationRequestMetadata struct {
	Message *string `json:"message,omitempty"`
}

// CreatePlaylist200Response defines model for createPlaylist_200_response.
type CreatePlaylist200Response struct {
	PlaylistMbid *openapi_types.UUID `json:"playlist_mbid,omitempty"`
	Status       *string             `json:"status,omitempty"`
}

// CreatePlaylistRequest defines model for createPlaylist_request.
type CreatePlaylistRequest struct {
	Playlist *Playlist `json:"playlist,omitempty"`
}

// CreateReviewRequest defines model for createReview_request.
type CreateReviewRequest struct {
	Metadata *CreateReviewRequestMetadata `json:"metadata,omitempty"`
}

// CreateReviewRequestMetadata defines model for createReview_request_metadata.
type CreateReviewRequestMetadata struct {
	EntityId   *string `json:"entity_id,omitempty"`
	EntityName *string `json:"entity_name,omitempty"`
	EntityType *string `json:"entity_type,omitempty"`
	Language   *string `json:"language,omitempty"`
	Rating     *int    `json:"rating,omitempty"`
	Text       *string `json:"text,omitempty"`
}

// DailyActivityForUser defines model for dailyActivityForUser.
type DailyActivityForUser struct {
	Payload DailyActivityForUserPayload `json:"payload"`
}

// DailyActivityForUserPayload defines model for dailyActivityForUser_payload.
type DailyActivityForUserPayload struct {
	DailyActivity DailyActivityForUserPayloadDailyActivity `json:"daily_activity"`
	FromTs        int                                      `json:"from_ts"`
	LastUpdated   int                                      `json:"last_updated"`
	Range         string                                   `json:"range"`
	ToTs          int                                      `json:"to_ts"`
	UserId        string                                   `json:"user_id"`
}

// DailyActivityForUserPayloadDailyActivity defines model for dailyActivityForUser_payload_daily_activity.
type DailyActivityForUserPayloadDailyActivity struct {
	Friday    []DailyActivityForUserPayloadDailyActivityFridayInner `json:"Friday"`
	Monday    []DailyActivityForUserPayloadDailyActivityFridayInner `json:"Monday"`
	Saturday  []DailyActivityForUserPayloadDailyActivityFridayInner `json:"Saturday"`
	Sunday    []DailyActivityForUserPayloadDailyActivityFridayInner `json:"Sunday"`
	Thursday  []DailyActivityForUserPayloadDailyActivityFridayInner `json:"Thursday"`
	Tuesday   []DailyActivityForUserPayloadDailyActivityFridayInner `json:"Tuesday"`
	Wednesday []DailyActivityForUserPayloadDailyActivityFridayInner `json:"Wednesday"`
}

// DailyActivityForUserPayloadDailyActivityFridayInner defines model for dailyActivityForUser_payload_daily_activity_Friday_inner.
type DailyActivityForUserPayloadDailyActivityFridayInner struct {
	Hour        *int `json:"hour,omitempty"`
	ListenCount *int `json:"listen_count,omitempty"`
}

// DeleteFeedbackRequest defines model for deleteFeedback_request.
type DeleteFeedbackRequest struct {
	RecordingMbid *openapi_types.UUID `json:"recording_mbid,omitempty"`
}

// DeleteListen defines model for deleteListen.
type DeleteListen struct {
	ListenedAt    int    `json:"listened_at"`
	RecordingMsid string `json:"recording_msid"`
}

// FeedEvents defines model for feedEvents.
type FeedEvents struct {
	Payload *FeedEventsPayload `json:"payload,omitempty"`
}

// FeedEventsDeleteRequest defines model for feedEventsDelete_request.
type FeedEventsDeleteRequest struct {
	EventType *string `json:"event_type,omitempty"`
	Id        *int    `json:"id,omitempty"`
}

// FeedEventsListensSimilar defines model for feedEventsListensSimilar.
type FeedEventsListensSimilar struct {
	Payload FeedEventsListensSimilarPayload `json:"payload"`
}

// FeedEventsListensSimilarPayload defines model for feedEventsListensSimilar_payload.
type FeedEventsListensSimilarPayload struct {
	Count  int                                          `json:"count"`
	Events []FeedEventsListensSimilarPayloadEventsInner `json:"events"`
	UserId string                                       `json:"user_id"`
}

// FeedEventsListensSimilarPayloadEventsInner defines model for feedEventsListensSimilar_payload_events_inner.
type FeedEventsListensSimilarPayloadEventsInner struct {
	Created    *int      `json:"created,omitempty"`
	EventType  *string   `json:"event_type,omitempty"`
	Hidden     *bool     `json:"hidden,omitempty"`
	Id         *string   `json:"id,omitempty"`
	Metadata   *Metadata `json:"metadata,omitempty"`
	Similarity *int      `json:"similarity,omitempty"`
	UserName   *string   `json:"user_name,omitempty"`
}

// FeedEventsPayload defines model for feedEvents_payload.
type FeedEventsPayload struct {
	Count  *int                            `json:"count,omitempty"`
	Events *[]FeedEventsPayloadEventsInner `json:"events,omitempty"`
	UserId *string                         `json:"user_id,omitempty"`
}

// FeedEventsPayloadEventsInner defines model for feedEvents_payload_events_inner.
type FeedEventsPayloadEventsInner struct {
	Created    *int      `json:"created,omitempty"`
	EventType  *string   `json:"event_type,omitempty"`
	Hidden     *bool     `json:"hidden,omitempty"`
	Id         *int      `json:"id,omitempty"`
	Message    *string   `json:"message,omitempty"`
	Metadata   *Metadata `json:"metadata,omitempty"`
	Similarity *float32  `json:"similarity,omitempty"`
	UserName   *string   `json:"user_name,omitempty"`
}

// Feedback defines model for feedback.
type Feedback struct {
	Created       *int                `json:"created,omitempty"`
	RecordingMbid *openapi_types.UUID `json:"recording_mbid,omitempty"`
	RecordingMsid *openapi_types.UUID `json:"recording_msid,omitempty"`
	Score         *int                `json:"score,omitempty"`
	TrackMetadata *TrackMetadata      `json:"track_metadata,omitempty"`
	UserId        *string             `json:"user_id,omitempty"`
}

// FeedbackGivenBy defines model for feedbackGivenBy.
type FeedbackGivenBy struct {
	Count      int                            `json:"count"`
	Feedback   []FeedbackGivenByFeedbackInner `json:"feedback"`
	Offset     int                            `json:"offset"`
	TotalCount int                            `json:"total_count"`
	UserName   string                         `json:"user_name"`
}

// FeedbackGivenByFeedbackInner defines model for feedbackGivenBy_feedback_inner.
type FeedbackGivenByFeedbackInner struct {
	Created       *int                `json:"created,omitempty"`
	Rating        *string             `json:"rating,omitempty"`
	RecordingMbid *openapi_types.UUID `json:"recording_mbid,omitempty"`
}

// FeedbackResponse defines model for feedbackResponse.
type FeedbackResponse struct {
	Count      *int        `json:"count,omitempty"`
	Feedback   *[]Feedback `json:"feedback,omitempty"`
	Offset     *int        `json:"offset,omitempty"`
	TotalCount *int        `json:"total_count,omitempty"`
}

// Followers defines model for followers.
type Followers struct {
	Followers []string `json:"followers"`
	User      string   `json:"user"`
}

// Following defines model for following.
type Following struct {
	Following []string `json:"following"`
	User      string   `json:"user"`
}

// FreshReleases defines model for freshReleases.
type FreshReleases struct {
	Payload FreshReleasesPayload `json:"payload"`
}

// FreshReleasesPayload defines model for freshReleases_payload.
type FreshReleasesPayload struct {
	Releases   []FreshReleasesPayloadReleasesInner `json:"releases"`
	TotalCount int                                 `json:"total_count"`
}

// FreshReleasesPayloadReleasesInner defines model for freshReleases_payload_releases_inner.
type FreshReleasesPayloadReleasesInner struct {
	ArtistCreditName        *string               `json:"artist_credit_name,omitempty"`
	ArtistMbids             *[]openapi_types.UUID `json:"artist_mbids,omitempty"`
	ListenCount             *int                  `json:"listen_count,omitempty"`
	ReleaseDate             *string               `json:"release_date,omitempty"`
	ReleaseGroupMbid        *openapi_types.UUID   `json:"release_group_mbid,omitempty"`
	ReleaseGroupPrimaryType *string               `json:"release_group_primary_type,omitempty"`
	ReleaseMbid             *openapi_types.UUID   `json:"release_mbid,omitempty"`
	ReleaseName             *string               `json:"release_name,omitempty"`
	ReleaseTags             *[]map[string]string  `json:"release_tags,omitempty"`
}

// GetDumpInfo defines model for getDumpInfo.
type GetDumpInfo struct {
	Id        int    `json:"id"`
	Timestamp string `json:"timestamp"`
}

// GetManualMapping defines model for getManualMapping.
type GetManualMapping struct {
	Mapping GetManualMappingMapping `json:"mapping"`
	Status  string                  `json:"status"`
}

// GetManualMappingMapping defines model for getManualMapping_mapping.
type GetManualMappingMapping struct {
	Created       string             `json:"created"`
	RecordingMbid openapi_types.UUID `json:"recording_mbid"`
	RecordingMsid openapi_types.UUID `json:"recording_msid"`
	UserId        int                `json:"user_id"`
}

// GetPins defines model for getPins.
type GetPins struct {
	Count            int                            `json:"count"`
	Offset           int                            `json:"offset"`
	PinnedRecordings []GetPinsPinnedRecordingsInner `json:"pinned_recordings"`
	TotalCount       *int                           `json:"total_count,omitempty"`
	UserName         string                         `json:"user_name"`
}

// GetPinsCurrent200Response defines model for getPinsCurrent_200_response.
type GetPinsCurrent200Response struct {
	PinnedRecording *GetPinsCurrent200ResponsePinnedRecording `json:"pinned_recording,omitempty"`
	UserName        *string                                   `json:"user_name,omitempty"`
}

// GetPinsCurrent200ResponsePinnedRecording defines model for getPinsCurrent_200_response_pinned_recording.
type GetPinsCurrent200ResponsePinnedRecording struct {
	BlurbContent  *string             `json:"blurb_content,omitempty"`
	Created       *int                `json:"created,omitempty"`
	PinnedUntil   *int                `json:"pinned_until,omitempty"`
	RecordingMbid *openapi_types.UUID `json:"recording_mbid,omitempty"`
	RecordingMsid *openapi_types.UUID `json:"recording_msid,omitempty"`
	RowId         *int                `json:"row_id,omitempty"`
	TrackMetadata *TrackMetadata      `json:"track_metadata,omitempty"`
}

// GetPinsPinnedRecordingsInner defines model for getPins_pinned_recordings_inner.
type GetPinsPinnedRecordingsInner struct {
	BlurbContent  *string             `json:"blurb_content,omitempty"`
	Created       *int                `json:"created,omitempty"`
	PinnedUntil   *int                `json:"pinned_until,omitempty"`
	RecordingMbid *openapi_types.UUID `json:"recording_mbid,omitempty"`
	RecordingMsid *string             `json:"recording_msid,omitempty"`
	RowId         *int                `json:"row_id,omitempty"`
	TrackMetadata *TrackMetadata      `json:"track_metadata,omitempty"`
}

// ItemDeleteRequest defines model for itemDelete_request.
type ItemDeleteRequest struct {
	Count *int `json:"count,omitempty"`
	Index *int `json:"index,omitempty"`
}

// LatestImport defines model for latestImport.
type LatestImport struct {
	// LatestImport the timestamp of the newest listen submitted in previous imports. Defaults to 0
	LatestImport string `json:"latest_import"`

	// MusicbrainzId the MusicBrainz ID of the user
	MusicbrainzId string              `json:"musicbrainz_id"`
	Status        *LatestImportStatus `json:"status,omitempty"`
}

// LatestImportStatus defines model for latestImport_status.
type LatestImportStatus struct {
	// Count the number of listens that have been imported for the user by the importer
	Count *int `json:"count,omitempty"`

	// State a short string denoting the state of the import
	State *string `json:"state,omitempty"`
}

// LbRadio defines model for lbRadio.
type LbRadio struct {
	Payload LbRadioPayload `json:"payload"`
}

// LbRadioRecordingsForArtist defines model for lbRadioRecordingsForArtist.
type LbRadioRecordingsForArtist map[string][]LbRadioRecordingsForArtistValueInner

// LbRadioRecordingsForArtistValueInner defines model for lbRadioRecordingsForArtist_value_inner.
type LbRadioRecordingsForArtistValueInner struct {
	RecordingMbid     *openapi_types.UUID `json:"recording_mbid,omitempty"`
	SimilarArtistMbid *openapi_types.UUID `json:"similar_artist_mbid,omitempty"`
	SimilarArtistName *string             `json:"similar_artist_name,omitempty"`
	TotalListenCount  *int                `json:"total_listen_count,omitempty"`
}

// LbRadioTags defines model for lbRadioTags.
type LbRadioTags = []LbRadioTagsInner

// LbRadioTagsInner defines model for lbRadioTags_inner.
type LbRadioTagsInner struct {
	Percent       *int                `json:"percent,omitempty"`
	RecordingMbid *openapi_types.UUID `json:"recording_mbid,omitempty"`
	Source        *string             `json:"source,omitempty"`
	TagCount      *int                `json:"tag_count,omitempty"`
}

// LbRadioPayload defines model for lbRadio_payload.
type LbRadioPayload struct {
	Feedback []string              `json:"feedback"`
	Jspf     CreatePlaylistRequest `json:"jspf"`
}

// ListenCountForUser defines model for listenCountForUser.
type ListenCountForUser struct {
	Payload ListenCountForUserPayload `json:"payload"`
}

// ListenCountForUserPayload defines model for listenCountForUser_payload.
type ListenCountForUserPayload struct {
	Count int `json:"count"`
}

// ListenersForArtist defines model for listenersForArtist.
type ListenersForArtist struct {
	Payload ListenersForArtistPayload `json:"payload"`
}

// ListenersForArtistPayload defines model for listenersForArtist_payload.
type ListenersForArtistPayload struct {
	ArtistMbid       openapi_types.UUID                        `json:"artist_mbid"`
	ArtistName       string                                    `json:"artist_name"`
	FromTs           int                                       `json:"from_ts"`
	LastUpdated      int                                       `json:"last_updated"`
	Listeners        []ListenersForArtistPayloadListenersInner `json:"listeners"`
	StatsRange       string                                    `json:"stats_range"`
	ToTs             int                                       `json:"to_ts"`
	TotalListenCount int                                       `json:"total_listen_count"`
	TotalUserCount   int                                       `json:"total_user_count"`
}

// ListenersForArtistPayloadListenersInner defines model for listenersForArtist_payload_listeners_inner.
type ListenersForArtistPayloadListenersInner struct {
	ListenCount *int    `json:"listen_count,omitempty"`
	UserName    *string `json:"user_name,omitempty"`
}

// ListenersForReleaseGroup defines model for listenersForReleaseGroup.
type ListenersForReleaseGroup struct {
	Payload ListenersForReleaseGroupPayload `json:"payload"`
}

// ListenersForReleaseGroupPayload defines model for listenersForReleaseGroup_payload.
type ListenersForReleaseGroupPayload struct {
	ArtistMbids      []openapi_types.UUID                      `json:"artist_mbids"`
	ArtistName       string                                    `json:"artist_name"`
	CaaId            int                                       `json:"caa_id"`
	CaaReleaseMbid   openapi_types.UUID                        `json:"caa_release_mbid"`
	FromTs           int                                       `json:"from_ts"`
	LastUpdated      int                                       `json:"last_updated"`
	Listeners        []ListenersForArtistPayloadListenersInner `json:"listeners"`
	ReleaseGroupMbid openapi_types.UUID                        `json:"release_group_mbid"`
	ReleaseGroupName string                                    `json:"release_group_name"`
	StatsRange       string                                    `json:"stats_range"`
	ToTs             int                                       `json:"to_ts"`
	TotalListenCount int                                       `json:"total_listen_count"`
	TotalUserCount   int                                       `json:"total_user_count"`
}

// ListeningActivityForUser defines model for listeningActivityForUser.
type ListeningActivityForUser struct {
	Payload ListeningActivityForUserPayload `json:"payload"`
}

// ListeningActivityForUserPayload defines model for listeningActivityForUser_payload.
type ListeningActivityForUserPayload struct {
	FromTs            int                                                     `json:"from_ts"`
	LastUpdated       int                                                     `json:"last_updated"`
	ListeningActivity []ListeningActivityForUserPayloadListeningActivityInner `json:"listening_activity"`
	Range             string                                                  `json:"range"`
	ToTs              int                                                     `json:"to_ts"`
	UserId            string                                                  `json:"user_id"`
}

// ListeningActivityForUserPayloadListeningActivityInner defines model for listeningActivityForUser_payload_listening_activity_inner.
type ListeningActivityForUserPayloadListeningActivityInner struct {
	FromTs      *int    `json:"from_ts,omitempty"`
	ListenCount *int    `json:"listen_count,omitempty"`
	TimeRange   *string `json:"time_range,omitempty"`
	ToTs        *int    `json:"to_ts,omitempty"`
}

// ListensForUser defines model for listensForUser.
type ListensForUser struct {
	Payload ListensForUserPayload `json:"payload"`
}

// ListensForUserPayload defines model for listensForUser_payload.
type ListensForUserPayload struct {
	Count          *int                                 `json:"count,omitempty"`
	LatestListenTs *int                                 `json:"latest_listen_ts,omitempty"`
	Listens        *[]ListensForUserPayloadListensInner `json:"listens,omitempty"`
	OldestListenTs *int                                 `json:"oldest_listen_ts,omitempty"`
	UserId         *string                              `json:"user_id,omitempty"`
}

// ListensForUserPayloadListensInner defines model for listensForUser_payload_listens_inner.
type ListensForUserPayloadListensInner struct {
	InsertedAt    *int           `json:"inserted_at,omitempty"`
	ListenedAt    *int           `json:"listened_at,omitempty"`
	RecordingMsid *string        `json:"recording_msid,omitempty"`
	TrackMetadata *TrackMetadata `json:"track_metadata,omitempty"`
	UserName      *string        `json:"user_name,omitempty"`
}

// Lookup defines model for lookup.
type Lookup struct {
	ArtistCreditName *string               `json:"artist_credit_name,omitempty"`
	ArtistMbids      *[]openapi_types.UUID `json:"artist_mbids,omitempty"`
	Metadata         *LookupMetadata       `json:"metadata,omitempty"`
	RecordingMbid    *openapi_types.UUID   `json:"recording_mbid,omitempty"`
	RecordingName    *string               `json:"recording_name,omitempty"`
	ReleaseMbid      *openapi_types.UUID   `json:"release_mbid,omitempty"`
	ReleaseName      *string               `json:"release_name,omitempty"`
}

// LookupMetadata defines model for lookup_metadata.
type LookupMetadata struct {
	Artist    *RecordingMetadataArtist `json:"artist,omitempty"`
	Recording *LookupMetadataRecording `json:"recording,omitempty"`
	Release   *LookupMetadataRelease   `json:"release,omitempty"`
	Tag       *LookupMetadataTag       `json:"tag,omitempty"`
}

// LookupMetadataRecording defines model for lookup_metadata_recording.
type LookupMetadataRecording struct {
	Length *int                                `json:"length,omitempty"`
	Name   *string                             `json:"name,omitempty"`
	Rels   *[]LookupMetadataRecordingRelsInner `json:"rels,omitempty"`
}

// LookupMetadataRecordingRelsInner defines model for lookup_metadata_recording_rels_inner.
type LookupMetadataRecordingRelsInner struct {
	ArtistMbid *openapi_types.UUID `json:"artist_mbid,omitempty"`
	ArtistName *string             `json:"artist_name,omitempty"`
	Instrument *string             `json:"instrument,omitempty"`
	Type       *string             `json:"type,omitempty"`
}

// LookupMetadataRelease defines model for lookup_metadata_release.
type LookupMetadataRelease struct {
	AlbumArtistName  *string             `json:"album_artist_name,omitempty"`
	CaaId            *int                `json:"caa_id,omitempty"`
	CaaReleaseMbid   *openapi_types.UUID `json:"caa_release_mbid,omitempty"`
	Mbid             *string             `json:"mbid,omitempty"`
	Name             *string             `json:"name,omitempty"`
	ReleaseGroupMbid *openapi_types.UUID `json:"release_group_mbid,omitempty"`
	Year             *int                `json:"year,omitempty"`
}

// LookupMetadataTag defines model for lookup_metadata_tag.
type LookupMetadataTag struct {
	Artist       *[]TopReleaseGroupsForArtistInnerTagArtistInner `json:"artist,omitempty"`
	Recording    *[]LookupMetadataTagRecordingInner              `json:"recording,omitempty"`
	ReleaseGroup *[]TopRecordingsForArtistInnerTagsInner         `json:"release_group,omitempty"`
}

// LookupMetadataTagRecordingInner defines model for lookup_metadata_tag_recording_inner.
type LookupMetadataTagRecordingInner struct {
	Count *int    `json:"count,omitempty"`
	Tag   *string `json:"tag,omitempty"`
}

// MbidMapping defines model for mbidMapping.
type MbidMapping struct {
	ArtistMbids    *[]openapi_types.UUID                                 `json:"artist_mbids,omitempty"`
	Artists        *[]TopReleasesForUserPayloadReleasesInnerArtistsInner `json:"artists,omitempty"`
	CaaId          *int                                                  `json:"caa_id,omitempty"`
	CaaReleaseMbid *openapi_types.UUID                                   `json:"caa_release_mbid,omitempty"`
	RecordingMbid  *openapi_types.UUID                                   `json:"recording_mbid,omitempty"`
	RecordingName  *string                                               `json:"recording_name,omitempty"`
	ReleaseMbid    *openapi_types.UUID                                   `json:"release_mbid,omitempty"`
}

// Metadata defines model for metadata.
type Metadata struct {
	BlurbContent         *string           `json:"blurb_content,omitempty"`
	Created              *int              `json:"created,omitempty"`
	InsertedAt           *int              `json:"inserted_at,omitempty"`
	ListenedAt           *int              `json:"listened_at,omitempty"`
	ListenedAtIso        *string           `json:"listened_at_iso,omitempty"`
	Message              *string           `json:"message,omitempty"`
	PlayingNow           *bool             `json:"playing_now,omitempty"`
	RelationshipType     *string           `json:"relationship_type,omitempty"`
	TrackMetadata        *TrackMetadata    `json:"track_metadata,omitempty"`
	UserName             *string           `json:"user_name,omitempty"`
	AdditionalProperties map[string]string `json:"-"`
}

// MoveItemRequest defines model for moveItem_request.
type MoveItemRequest struct {
	Count *int                `json:"count,omitempty"`
	From  *int                `json:"from,omitempty"`
	Mbid  *openapi_types.UUID `json:"mbid,omitempty"`
	To    *int                `json:"to,omitempty"`
}

// MusicBrainzArtist defines model for musicBrainzArtist.
type MusicBrainzArtist struct {
	Area       *string             `json:"area,omitempty"`
	ArtistMbid *openapi_types.UUID `json:"artist_mbid,omitempty"`
	BeginYear  *int                `json:"begin_year,omitempty"`
	EndYear    *int                `json:"end_year,omitempty"`
	Gender     *string             `json:"gender,omitempty"`
	JoinPhrase *string             `json:"join_phrase,omitempty"`
	Name       *string             `json:"name,omitempty"`
	Rels       *Rels1              `json:"rels,omitempty"`
	Type       *string             `json:"type,omitempty"`
}

// Pin200Response defines model for pin_200_response.
type Pin200Response struct {
	PinnedRecording *Pin200ResponsePinnedRecording `json:"pinned_recording,omitempty"`
}

// Pin200ResponsePinnedRecording defines model for pin_200_response_pinned_recording.
type Pin200ResponsePinnedRecording struct {
	BlurbContent  *string             `json:"blurb_content,omitempty"`
	Created       *int                `json:"created,omitempty"`
	PinnedUntil   *int                `json:"pinned_until,omitempty"`
	RecordingMbid *openapi_types.UUID `json:"recording_mbid,omitempty"`
	RecordingMsid *openapi_types.UUID `json:"recording_msid,omitempty"`
	RowId         *int                `json:"row_id,omitempty"`
	TrackMetadata *TrackMetadata      `json:"track_metadata,omitempty"`
}

// PinRequest defines model for pin_request.
type PinRequest struct {
	BlurbContent  *string             `json:"blurb_content,omitempty"`
	PinnedUntil   *int64              `json:"pinned_until,omitempty"`
	RecordingMbid *openapi_types.UUID `json:"recording_mbid,omitempty"`
	RecordingMsid *openapi_types.UUID `json:"recording_msid,omitempty"`
}

// PlayingNowForUser defines model for playingNowForUser.
type PlayingNowForUser struct {
	Payload PlayingNowForUserPayload `json:"payload"`
}

// PlayingNowForUserPayload defines model for playingNowForUser_payload.
type PlayingNowForUserPayload struct {
	Count      int                                    `json:"count"`
	Listens    []PlayingNowForUserPayloadListensInner `json:"listens"`
	PlayingNow bool                                   `json:"playing_now"`
	UserId     string                                 `json:"user_id"`
}

// PlayingNowForUserPayloadListensInner defines model for playingNowForUser_payload_listens_inner.
type PlayingNowForUserPayloadListensInner struct {
	PlayingNow    *bool          `json:"playing_now,omitempty"`
	TrackMetadata *TrackMetadata `json:"track_metadata,omitempty"`
}

// Playlist defines model for playlist.
type Playlist struct {
	Album      *string               `json:"album,omitempty"`
	Annotation *string               `json:"annotation,omitempty"`
	Creator    *string               `json:"creator,omitempty"`
	Date       *string               `json:"date,omitempty"`
	Duration   *int                  `json:"duration,omitempty"`
	Extension  *PlaylistExtension    `json:"extension,omitempty"`
	Identifier *string               `json:"identifier,omitempty"`
	Title      *string               `json:"title,omitempty"`
	Track      *[]PlaylistTrackInner `json:"track,omitempty"`
}

// PlaylistExtension defines model for playlist-extension.
type PlaylistExtension struct {
	HttpsmusicbrainzOrgdocjspfPlaylist *PlaylistExtensionPayload `json:"https://musicbrainz.org/doc/jspf#playlist,omitempty"`
}

// PlaylistExtensionPayload defines model for playlistExtensionPayload.
type PlaylistExtensionPayload struct {
	AdditionalMetadata *PlaylistExtensionPayloadAdditionalMetadata `json:"additional_metadata,omitempty"`
	Collaborators      *[]string                                   `json:"collaborators,omitempty"`
	CopiedFrom         *string                                     `json:"copied_from,omitempty"`
	CopiedFromDeleted  *bool                                       `json:"copied_from_deleted,omitempty"`
	CreatedFor         *string                                     `json:"created_for,omitempty"`
	Creator            *string                                     `json:"creator,omitempty"`
	LastModifiedAt     *string                                     `json:"last_modified_at,omitempty"`
	Public             *bool                                       `json:"public,omitempty"`
}

// PlaylistExtensionPayloadAdditionalMetadata defines model for playlistExtensionPayload_additional_metadata.
type PlaylistExtensionPayloadAdditionalMetadata struct {
	AlgorithmMetadata    *PlaylistExtensionPayloadAdditionalMetadataAlgorithmMetadata `json:"algorithm_metadata,omitempty"`
	CoverArt             *PlaylistExtensionPayloadAdditionalMetadataCoverArt          `json:"cover_art,omitempty"`
	AdditionalProperties map[string]string                                            `json:"-"`
}

// PlaylistExtensionPayloadAdditionalMetadataAlgorithmMetadata defines model for playlistExtensionPayload_additional_metadata_algorithm_metadata.
type PlaylistExtensionPayloadAdditionalMetadataAlgorithmMetadata struct {
	SourcePatch *string `json:"source_patch,omitempty"`
}

// PlaylistExtensionPayloadAdditionalMetadataCoverArt defines model for playlistExtensionPayload_additional_metadata_cover_art.
type PlaylistExtensionPayloadAdditionalMetadataCoverArt struct {
	Dimension *int `json:"dimension,omitempty"`
	Layout    *int `json:"layout,omitempty"`
}

// PlaylistTrackInner defines model for playlist_track_inner.
type PlaylistTrackInner struct {
	Album      *string                      `json:"album,omitempty"`
	Creator    *string                      `json:"creator,omitempty"`
	Duration   *int                         `json:"duration,omitempty"`
	Extension  *PlaylistTrackInnerExtension `json:"extension,omitempty"`
	Identifier *[]string                    `json:"identifier,omitempty"`
	Title      *string                      `json:"title,omitempty"`
}

// PlaylistTrackInnerExtension defines model for playlist_track_inner_extension.
type PlaylistTrackInnerExtension struct {
	HttpsmusicbrainzOrgdocjspfTrack PlaylistTrackInnerExtensionHttpsMusicbrainzOrgDocJspfTrack `json:"https://musicbrainz.org/doc/jspf#track"`
}

// PlaylistTrackInnerExtensionHttpsMusicbrainzOrgDocJspfTrack defines model for playlist_track_inner_extension_https___musicbrainz_org_doc_jspf_track.
type PlaylistTrackInnerExtensionHttpsMusicbrainzOrgDocJspfTrack struct {
	AddedAt            *string                                                                       `json:"added_at,omitempty"`
	AddedBy            *string                                                                       `json:"added_by,omitempty"`
	AdditionalMetadata *PlaylistTrackInnerExtensionHttpsMusicbrainzOrgDocJspfTrackAdditionalMetadata `json:"additional_metadata,omitempty"`
	ArtistIdentifiers  *[]string                                                                     `json:"artist_identifiers,omitempty"`
	ReleaseIdentifier  *string                                                                       `json:"release_identifier,omitempty"`
}

// PlaylistTrackInnerExtensionHttpsMusicbrainzOrgDocJspfTrackAdditionalMetadata defines model for playlist_track_inner_extension_https___musicbrainz_org_doc_jspf_track_additional_metadata.
type PlaylistTrackInnerExtensionHttpsMusicbrainzOrgDocJspfTrackAdditionalMetadata struct {
	Artists        *[]TopReleasesForUserPayloadReleasesInnerArtistsInner `json:"artists,omitempty"`
	CaaId          *int                                                  `json:"caa_id,omitempty"`
	CaaReleaseMbid *openapi_types.UUID                                   `json:"caa_release_mbid,omitempty"`
}

// Playlists defines model for playlists.
type Playlists struct {
	Count         *int                     `json:"count,omitempty"`
	Offset        *int                     `json:"offset,omitempty"`
	PlaylistCount *int                     `json:"playlist_count,omitempty"`
	Playlists     *[]CreatePlaylistRequest `json:"playlists,omitempty"`
}

// RecommendPersonalRecordingRequest defines model for recommendPersonalRecording_request.
type RecommendPersonalRecordingRequest struct {
	Metadata *RecommendPersonalRecordingRequestMetadata `json:"metadata,omitempty"`
}

// RecommendPersonalRecordingRequestMetadata defines model for recommendPersonalRecording_request_metadata.
type RecommendPersonalRecordingRequestMetadata struct {
	BlurbContent  *string             `json:"blurb_content,omitempty"`
	RecordingMbid *openapi_types.UUID `json:"recording_mbid,omitempty"`
	RecordingMsid *openapi_types.UUID `json:"recording_msid,omitempty"`
	Users         *string             `json:"users,omitempty"`
}

// RecommendRecordingRequest defines model for recommendRecording_request.
type RecommendRecordingRequest struct {
	Metadata *RecommendRecordingRequestMetadata `json:"metadata,omitempty"`
}

// RecommendRecordingRequestMetadata defines model for recommendRecording_request_metadata.
type RecommendRecordingRequestMetadata struct {
	RecordingMbid *openapi_types.UUID `json:"recording_mbid,omitempty"`
	RecordingMsid *openapi_types.UUID `json:"recording_msid,omitempty"`
}

// RecordingFeedbackRequest defines model for recordingFeedback_request.
type RecordingFeedbackRequest struct {
	RecordingMbid *openapi_types.UUID `json:"recording_mbid,omitempty"`
	RecordingMsid *openapi_types.UUID `json:"recording_msid,omitempty"`
	Score         *int                `json:"score,omitempty"`
}

// RecordingMetadata defines model for recordingMetadata.
type RecordingMetadata struct {
	Artist    *RecordingMetadataArtist    `json:"artist,omitempty"`
	Recording *RecordingMetadataRecording `json:"recording,omitempty"`
	Tag       *RecordingMetadataTag       `json:"tag,omitempty"`
}

// RecordingMetadataArtist defines model for recordingMetadata_artist.
type RecordingMetadataArtist struct {
	ArtistCreditId *int                                   `json:"artist_credit_id,omitempty"`
	Artists        *[]RecordingMetadataArtistArtistsInner `json:"artists,omitempty"`
	Name           *string                                `json:"name,omitempty"`
}

// RecordingMetadataArtistArtistsInner defines model for recordingMetadata_artist_artists_inner.
type RecordingMetadataArtistArtistsInner struct {
	Area       *string             `json:"area,omitempty"`
	ArtistMbid *openapi_types.UUID `json:"artist_mbid,omitempty"`
	BeginYear  *int                `json:"begin_year,omitempty"`
	JoinPhrase *string             `json:"join_phrase,omitempty"`
	Name       *string             `json:"name,omitempty"`
	Rels       *Rels1              `json:"rels,omitempty"`
	Type       *string             `json:"type,omitempty"`
}

// RecordingMetadataRecording defines model for recordingMetadata_recording.
type RecordingMetadataRecording struct {
	Length *int    `json:"length,omitempty"`
	Name   *string `json:"name,omitempty"`
	Rels   *[]Rels `json:"rels,omitempty"`
}

// RecordingMetadataTag defines model for recordingMetadata_tag.
type RecordingMetadataTag struct {
	Artist       *[]TopReleaseGroupsForArtistInnerTagArtistInner `json:"artist,omitempty"`
	Recording    *[]TopRecordingsForArtistInnerTagsInner         `json:"recording,omitempty"`
	ReleaseGroup *[]TopRecordingsForArtistInnerTagsInner         `json:"release_group,omitempty"`
}

// RecordingRecommendations defines model for recordingRecommendations.
type RecordingRecommendations struct {
	Payload RecordingRecommendationsPayload `json:"payload"`
}

// RecordingRecommendationsPayload defines model for recordingRecommendations_payload.
type RecordingRecommendationsPayload struct {
	Count          int                                         `json:"count"`
	Entity         string                                      `json:"entity"`
	LastUpdated    int                                         `json:"last_updated"`
	Mbids          []RecordingRecommendationsPayloadMbidsInner `json:"mbids"`
	ModelId        string                                      `json:"model_id"`
	ModelUrl       string                                      `json:"model_url"`
	Offset         int                                         `json:"offset"`
	TotalMbidCount int                                         `json:"total_mbid_count"`
	UserName       string                                      `json:"user_name"`
}

// RecordingRecommendationsPayloadMbidsInner defines model for recordingRecommendations_payload_mbids_inner.
type RecordingRecommendationsPayloadMbidsInner struct {
	LatestListenedAt *string             `json:"latest_listened_at,omitempty"`
	RecordingMbid    *openapi_types.UUID `json:"recording_mbid,omitempty"`
	Score            *int                `json:"score,omitempty"`
}

// Recording200ResponseInner defines model for recording_200_response_inner.
type Recording200ResponseInner struct {
	RecordingMbid    *openapi_types.UUID `json:"recording_mbid,omitempty"`
	TotalListenCount *int                `json:"total_listen_count,omitempty"`
	TotalUserCount   *int                `json:"total_user_count,omitempty"`
}

// RecordingRequest defines model for recording_request.
type RecordingRequest struct {
	RecordingMbids []openapi_types.UUID `json:"recording_mbids"`
}

// RecordingsFeedbackGivenBy defines model for recordingsFeedbackGivenBy.
type RecordingsFeedbackGivenBy struct {
	Feedback []FeedbackGivenByFeedbackInner `json:"feedback"`
	UserName string                         `json:"user_name"`
}

// ReleaseGroupMetadata defines model for releaseGroupMetadata.
type ReleaseGroupMetadata struct {
	Artist       *ReleaseGroupMetadataArtist        `json:"artist,omitempty"`
	Release      *ReleaseGroupMetadataReleaseGroup  `json:"release,omitempty"`
	ReleaseGroup *ReleaseGroupMetadataReleaseGroup  `json:"release_group,omitempty"`
	Tag          *TopReleaseGroupsForArtistInnerTag `json:"tag,omitempty"`
}

// ReleaseGroupMetadataArtist defines model for releaseGroupMetadata_artist.
type ReleaseGroupMetadataArtist struct {
	ArtistCreditId *int                                      `json:"artist_credit_id,omitempty"`
	Artists        *[]ReleaseGroupMetadataArtistArtistsInner `json:"artists,omitempty"`
	Name           *string                                   `json:"name,omitempty"`
}

// ReleaseGroupMetadataArtistArtistsInner defines model for releaseGroupMetadata_artist_artists_inner.
type ReleaseGroupMetadataArtistArtistsInner struct {
	Area       *string             `json:"area,omitempty"`
	ArtistMbid *openapi_types.UUID `json:"artist_mbid,omitempty"`
	BeginYear  *int                `json:"begin_year,omitempty"`
	EndYear    *int                `json:"end_year,omitempty"`
	JoinPhrase *string             `json:"join_phrase,omitempty"`
	Name       *string             `json:"name,omitempty"`
	Rels       *Rels1              `json:"rels,omitempty"`
	Type       *string             `json:"type,omitempty"`
}

// ReleaseGroupMetadataReleaseGroup defines model for releaseGroupMetadata_release_group.
type ReleaseGroupMetadataReleaseGroup struct {
	CaaId          *int                 `json:"caa_id,omitempty"`
	CaaReleaseMbid *openapi_types.UUID  `json:"caa_release_mbid,omitempty"`
	Date           *string              `json:"date,omitempty"`
	Name           *string              `json:"name,omitempty"`
	Rels           *[]map[string]string `json:"rels,omitempty"`
	Type           *string              `json:"type,omitempty"`
}

// ReleaseGroup200ResponseInner defines model for releaseGroup_200_response_inner.
type ReleaseGroup200ResponseInner struct {
	ReleaseGroupMbid *openapi_types.UUID `json:"release_group_mbid,omitempty"`
	TotalListenCount *int                `json:"total_listen_count,omitempty"`
	TotalUserCount   *int                `json:"total_user_count,omitempty"`
}

// ReleaseGroupRequest defines model for releaseGroup_request.
type ReleaseGroupRequest struct {
	ReleaseGroupMbids []openapi_types.UUID `json:"release_group_mbids"`
}

// ReleaseGroupsInner defines model for releaseGroups_inner.
type ReleaseGroupsInner struct {
	ArtistMbids      *[]openapi_types.UUID             `json:"artist_mbids,omitempty"`
	ArtistName       *string                           `json:"artist_name,omitempty"`
	Artists          *[]ReleaseGroupsInnerArtistsInner `json:"artists,omitempty"`
	CaaId            *int                              `json:"caa_id,omitempty"`
	CaaReleaseMbid   *openapi_types.UUID               `json:"caa_release_mbid,omitempty"`
	ListenCount      *int                              `json:"listen_count,omitempty"`
	ReleaseGroupMbid *openapi_types.UUID               `json:"release_group_mbid,omitempty"`
	ReleaseGroupName *string                           `json:"release_group_name,omitempty"`
}

// ReleaseGroupsInnerArtistsInner defines model for releaseGroups_inner_artists_inner.
type ReleaseGroupsInnerArtistsInner struct {
	ArtistCreditName *string             `json:"artist_credit_name,omitempty"`
	ArtistMbid       *openapi_types.UUID `json:"artist_mbid,omitempty"`
	ArtistName       *string             `json:"artist_name,omitempty"`
	JoinPhrase       *string             `json:"join_phrase,omitempty"`
	ListenCount      *int                `json:"listen_count,omitempty"`
}

// Release200ResponseInner defines model for release_200_response_inner.
type Release200ResponseInner struct {
	ReleaseMbid      *openapi_types.UUID `json:"release_mbid,omitempty"`
	TotalListenCount *int                `json:"total_listen_count,omitempty"`
	TotalUserCount   *int                `json:"total_user_count,omitempty"`
}

// ReleaseRequest defines model for release_request.
type ReleaseRequest struct {
	ReleaseMbids []openapi_types.UUID `json:"release_mbids"`
}

// Rels defines model for rels.
type Rels struct {
	ArtistMbid *openapi_types.UUID `json:"artist_mbid,omitempty"`
	ArtistName *string             `json:"artist_name,omitempty"`
	Instrument *string             `json:"instrument,omitempty"`
	Type       *string             `json:"type,omitempty"`
}

// Rels1 defines model for rels_1.
type Rels1 struct {
	Blog                 *string `json:"blog,omitempty"`
	Crowdfunding         *string `json:"crowdfunding,omitempty"`
	DownloadForFree      *string `json:"download for free,omitempty"`
	FreeStreaming        *string `json:"free streaming,omitempty"`
	Lyrics               *string `json:"lyrics,omitempty"`
	OfficialHomepage     *string `json:"official homepage,omitempty"`
	Patronage            *string `json:"patronage,omitempty"`
	PurchaseForDownload  *string `json:"purchase for download,omitempty"`
	PurchaseForMailOrder *string `json:"purchase for mail-order,omitempty"`
	SocialNetwork        *string `json:"social network,omitempty"`
	Streaming            *string `json:"streaming,omitempty"`
	Wikidata             *string `json:"wikidata,omitempty"`
	Youtube              *string `json:"youtube,omitempty"`
}

// SearchUsers defines model for searchUsers.
type SearchUsers struct {
	Users []SearchUsersUsersInner `json:"users"`
}

// SearchUsersUsersInner defines model for searchUsers_users_inner.
type SearchUsersUsersInner struct {
	UserName *string `json:"user_name,omitempty"`
}

// ServicesForUser defines model for servicesForUser.
type ServicesForUser struct {
	Services []string `json:"services"`
	UserName string   `json:"user_name"`
}

// SimilarUsersForUser defines model for similarUsersForUser.
type SimilarUsersForUser struct {
	Payload []SimilarUsersForUserPayloadInner `json:"payload"`
}

// SimilarUsersForUserPayloadInner defines model for similarUsersForUser_payload_inner.
type SimilarUsersForUserPayloadInner struct {
	Similarity *int    `json:"similarity,omitempty"`
	UserName   *string `json:"user_name,omitempty"`
}

// SimilarityOfUserForUser defines model for similarityOfUserForUser.
type SimilarityOfUserForUser struct {
	Payload SimilarityOfUserForUserPayload `json:"payload"`
}

// SimilarityOfUserForUserPayload defines model for similarityOfUserForUser_payload.
type SimilarityOfUserForUserPayload struct {
	Similarity int    `json:"similarity"`
	UserName   string `json:"user_name"`
}

// SitewideArtistMap defines model for sitewideArtistMap.
type SitewideArtistMap struct {
	Payload SitewideArtistMapPayload `json:"payload"`
}

// SitewideArtistMapPayload defines model for sitewideArtistMap_payload.
type SitewideArtistMapPayload struct {
	ArtistMap   []ArtistMapForUserPayloadArtistMapInner `json:"artist_map"`
	FromTs      int                                     `json:"from_ts"`
	LastUpdated int                                     `json:"last_updated"`
	StatsRange  *string                                 `json:"stats_range,omitempty"`
	ToTs        int                                     `json:"to_ts"`
}

// SitewideListeningActivity defines model for sitewideListeningActivity.
type SitewideListeningActivity struct {
	Payload SitewideListeningActivityPayload `json:"payload"`
}

// SitewideListeningActivityPayload defines model for sitewideListeningActivity_payload.
type SitewideListeningActivityPayload struct {
	FromTs            int                                                     `json:"from_ts"`
	LastUpdated       int                                                     `json:"last_updated"`
	ListeningActivity []ListeningActivityForUserPayloadListeningActivityInner `json:"listening_activity"`
	Range             string                                                  `json:"range"`
	ToTs              int                                                     `json:"to_ts"`
}

// SitewideTopArtists defines model for sitewideTopArtists.
type SitewideTopArtists struct {
	Payload SitewideTopArtistsPayload `json:"payload"`
}

// SitewideTopArtistsPayload defines model for sitewideTopArtists_payload.
type SitewideTopArtistsPayload struct {
	Artists          []TopArtistsForUserPayloadArtistsInner `json:"artists"`
	Count            int                                    `json:"count"`
	FromTs           int                                    `json:"from_ts"`
	LastUpdated      int                                    `json:"last_updated"`
	Offset           int                                    `json:"offset"`
	Range            string                                 `json:"range"`
	ToTs             int                                    `json:"to_ts"`
	TotalArtistCount int                                    `json:"total_artist_count"`
}

// SitewideTopRecordings defines model for sitewideTopRecordings.
type SitewideTopRecordings struct {
	Payload SitewideTopRecordingsPayload `json:"payload"`
}

// SitewideTopRecordingsPayload defines model for sitewideTopRecordings_payload.
type SitewideTopRecordingsPayload struct {
	Count               int                                           `json:"count"`
	FromTs              int                                           `json:"from_ts"`
	LastUpdated         int                                           `json:"last_updated"`
	Offset              int                                           `json:"offset"`
	Range               string                                        `json:"range"`
	Recordings          []SitewideTopRecordingsPayloadRecordingsInner `json:"recordings"`
	ToTs                int                                           `json:"to_ts"`
	TotalRecordingCount int                                           `json:"total_recording_count"`
}

// SitewideTopRecordingsPayloadRecordingsInner defines model for sitewideTopRecordings_payload_recordings_inner.
type SitewideTopRecordingsPayloadRecordingsInner struct {
	ArtistMbids    *[]openapi_types.UUID `json:"artist_mbids,omitempty"`
	ArtistName     *string               `json:"artist_name,omitempty"`
	Artists        *[]string             `json:"artists,omitempty"`
	CaaId          *int                  `json:"caa_id,omitempty"`
	CaaReleaseMbid *openapi_types.UUID   `json:"caa_release_mbid,omitempty"`
	ListenCount    *int                  `json:"listen_count,omitempty"`
	RecordingMbid  *openapi_types.UUID   `json:"recording_mbid,omitempty"`
	ReleaseMbid    *openapi_types.UUID   `json:"release_mbid,omitempty"`
	ReleaseName    *string               `json:"release_name,omitempty"`
	TrackName      *string               `json:"track_name,omitempty"`
}

// SitewideTopReleaseGroups defines model for sitewideTopReleaseGroups.
type SitewideTopReleaseGroups struct {
	Payload SitewideTopReleaseGroupsPayload `json:"payload"`
}

// SitewideTopReleaseGroupsPayload defines model for sitewideTopReleaseGroups_payload.
type SitewideTopReleaseGroupsPayload struct {
	Count                  int                  `json:"count"`
	FromTs                 int                  `json:"from_ts"`
	LastUpdated            int                  `json:"last_updated"`
	Offset                 int                  `json:"offset"`
	Range                  string               `json:"range"`
	ReleaseGroups          []ReleaseGroupsInner `json:"release_groups"`
	ToTs                   int                  `json:"to_ts"`
	TotalReleaseGroupCount int                  `json:"total_release_group_count"`
}

// SitewideTopReleases defines model for sitewideTopReleases.
type SitewideTopReleases struct {
	Payload SitewideTopReleasesPayload `json:"payload"`
}

// SitewideTopReleasesPayload defines model for sitewideTopReleases_payload.
type SitewideTopReleasesPayload struct {
	Count             int                                       `json:"count"`
	FromTs            int                                       `json:"from_ts"`
	LastUpdated       int                                       `json:"last_updated"`
	Offset            int                                       `json:"offset"`
	Range             string                                    `json:"range"`
	Releases          []SitewideTopReleasesPayloadReleasesInner `json:"releases"`
	ToTs              int                                       `json:"to_ts"`
	TotalReleaseCount int                                       `json:"total_release_count"`
}

// SitewideTopReleasesPayloadReleasesInner defines model for sitewideTopReleases_payload_releases_inner.
type SitewideTopReleasesPayloadReleasesInner struct {
	ArtistMbids    *[]openapi_types.UUID `json:"artist_mbids,omitempty"`
	ArtistName     *string               `json:"artist_name,omitempty"`
	Artists        *string               `json:"artists"`
	CaaId          *int                  `json:"caa_id,omitempty"`
	CaaReleaseMbid *openapi_types.UUID   `json:"caa_release_mbid,omitempty"`
	ListenCount    *int                  `json:"listen_count,omitempty"`
	ReleaseMbid    *openapi_types.UUID   `json:"release_mbid,omitempty"`
	ReleaseName    *string               `json:"release_name,omitempty"`
}

// SubmitFeedbackRequest defines model for submitFeedback_request.
type SubmitFeedbackRequest struct {
	Rating        *AllowedRatings     `json:"rating,omitempty"`
	RecordingMbid *openapi_types.UUID `json:"recording_mbid,omitempty"`
}

// SubmitListens defines model for submitListens.
type SubmitListens struct {
	ListenType ListenType                  `json:"listen_type"`
	Payload    []SubmitListensPayloadInner `json:"payload"`
}

// SubmitListensPayloadInner defines model for submitListens_payload_inner.
type SubmitListensPayloadInner struct {
	ListenedAt    *int32         `json:"listened_at,omitempty"`
	TrackMetadata *TrackMetadata `json:"track_metadata,omitempty"`
}

// SubmitManualMapping defines model for submitManualMapping.
type SubmitManualMapping struct {
	RecordingMbid *openapi_types.UUID `json:"recording_mbid,omitempty"`
	RecordingMsid *openapi_types.UUID `json:"recording_msid,omitempty"`
}

// TopArtistsForUser defines model for topArtistsForUser.
type TopArtistsForUser struct {
	Payload TopArtistsForUserPayload `json:"payload"`
}

// TopArtistsForUserPayload defines model for topArtistsForUser_payload.
type TopArtistsForUserPayload struct {
	Artists          []TopArtistsForUserPayloadArtistsInner `json:"artists"`
	Count            int                                    `json:"count"`
	FromTs           int                                    `json:"from_ts"`
	LastUpdated      int                                    `json:"last_updated"`
	Offset           int                                    `json:"offset"`
	Range            string                                 `json:"range"`
	ToTs             int                                    `json:"to_ts"`
	TotalArtistCount int                                    `json:"total_artist_count"`
	UserId           string                                 `json:"user_id"`
}

// TopArtistsForUserPayloadArtistsInner defines model for topArtistsForUser_payload_artists_inner.
type TopArtistsForUserPayloadArtistsInner struct {
	ArtistMbid  *openapi_types.UUID `json:"artist_mbid,omitempty"`
	ArtistName  *string             `json:"artist_name,omitempty"`
	ListenCount *int                `json:"listen_count,omitempty"`
}

// TopRecordingsForArtist defines model for topRecordingsForArtist.
type TopRecordingsForArtist = []TopRecordingsForArtistInner

// TopRecordingsForArtistInner defines model for topRecordingsForArtist_inner.
type TopRecordingsForArtistInner struct {
	ArtistMbids      *[]openapi_types.UUID                                 `json:"artist_mbids,omitempty"`
	ArtistName       *string                                               `json:"artist_name,omitempty"`
	Artists          *[]TopReleasesForUserPayloadReleasesInnerArtistsInner `json:"artists,omitempty"`
	CaaId            *int                                                  `json:"caa_id,omitempty"`
	CaaReleaseMbid   *openapi_types.UUID                                   `json:"caa_release_mbid,omitempty"`
	Length           *int                                                  `json:"length,omitempty"`
	RecordingMbid    *openapi_types.UUID                                   `json:"recording_mbid,omitempty"`
	RecordingName    *string                                               `json:"recording_name,omitempty"`
	ReleaseColor     *TopRecordingsForArtistInnerReleaseColor              `json:"release_color,omitempty"`
	ReleaseMbid      *openapi_types.UUID                                   `json:"release_mbid,omitempty"`
	ReleaseName      *string                                               `json:"release_name,omitempty"`
	Tags             *[]TopRecordingsForArtistInnerTagsInner               `json:"tags,omitempty"`
	TotalListenCount *int                                                  `json:"total_listen_count,omitempty"`
	TotalUserCount   *int                                                  `json:"total_user_count,omitempty"`
}

// TopRecordingsForArtistInnerReleaseColor defines model for topRecordingsForArtist_inner_release_color.
type TopRecordingsForArtistInnerReleaseColor struct {
	Blue  *int `json:"blue,omitempty"`
	Green *int `json:"green,omitempty"`
	Red   *int `json:"red,omitempty"`
}

// TopRecordingsForArtistInnerTagsInner defines model for topRecordingsForArtist_inner_tags_inner.
type TopRecordingsForArtistInnerTagsInner struct {
	Count     *int                `json:"count,omitempty"`
	GenreMbid *openapi_types.UUID `json:"genre_mbid,omitempty"`
	Tag       *string             `json:"tag,omitempty"`
}

// TopRecordingsForUser defines model for topRecordingsForUser.
type TopRecordingsForUser struct {
	Payload TopRecordingsForUserPayload `json:"payload"`
}

// TopRecordingsForUserPayload defines model for topRecordingsForUser_payload.
type TopRecordingsForUserPayload struct {
	Count               int                                          `json:"count"`
	FromTs              int                                          `json:"from_ts"`
	LastUpdated         int                                          `json:"last_updated"`
	Offset              int                                          `json:"offset"`
	Range               string                                       `json:"range"`
	Recordings          []TopRecordingsForUserPayloadRecordingsInner `json:"recordings"`
	ToTs                int                                          `json:"to_ts"`
	TotalRecordingCount int                                          `json:"total_recording_count"`
	UserId              string                                       `json:"user_id"`
}

// TopRecordingsForUserPayloadRecordingsInner defines model for topRecordingsForUser_payload_recordings_inner.
type TopRecordingsForUserPayloadRecordingsInner struct {
	ArtistMbids    *[]openapi_types.UUID                                 `json:"artist_mbids,omitempty"`
	ArtistName     *string                                               `json:"artist_name,omitempty"`
	Artists        *[]TopReleasesForUserPayloadReleasesInnerArtistsInner `json:"artists,omitempty"`
	CaaId          *int                                                  `json:"caa_id,omitempty"`
	CaaReleaseMbid *openapi_types.UUID                                   `json:"caa_release_mbid,omitempty"`
	ListenCount    *int                                                  `json:"listen_count,omitempty"`
	RecordingMbid  *openapi_types.UUID                                   `json:"recording_mbid,omitempty"`
	ReleaseMbid    *openapi_types.UUID                                   `json:"release_mbid,omitempty"`
	ReleaseName    *string                                               `json:"release_name,omitempty"`
	TrackName      *string                                               `json:"track_name,omitempty"`
}

// TopReleaseGroupsForArtist defines model for topReleaseGroupsForArtist.
type TopReleaseGroupsForArtist = []TopReleaseGroupsForArtistInner

// TopReleaseGroupsForArtistInner defines model for topReleaseGroupsForArtist_inner.
type TopReleaseGroupsForArtistInner struct {
	Artist           *TopReleaseGroupsForArtistInnerArtist       `json:"artist,omitempty"`
	Release          *TopReleaseGroupsForArtistInnerRelease      `json:"release,omitempty"`
	ReleaseColor     *TopRecordingsForArtistInnerReleaseColor    `json:"release_color,omitempty"`
	ReleaseGroup     *TopReleaseGroupsForArtistInnerReleaseGroup `json:"release_group,omitempty"`
	ReleaseGroupMbid *openapi_types.UUID                         `json:"release_group_mbid,omitempty"`
	Tag              *TopReleaseGroupsForArtistInnerTag          `json:"tag,omitempty"`
	TotalListenCount *int                                        `json:"total_listen_count,omitempty"`
	TotalUserCount   *int                                        `json:"total_user_count,omitempty"`
}

// TopReleaseGroupsForArtistInnerArtist defines model for topReleaseGroupsForArtist_inner_artist.
type TopReleaseGroupsForArtistInnerArtist struct {
	ArtistCreditId *int                 `json:"artist_credit_id,omitempty"`
	Artists        *[]MusicBrainzArtist `json:"artists,omitempty"`
	Name           *string              `json:"name,omitempty"`
}

// TopReleaseGroupsForArtistInnerRelease defines model for topReleaseGroupsForArtist_inner_release.
type TopReleaseGroupsForArtistInnerRelease struct {
	CaaId          *int                `json:"caa_id,omitempty"`
	CaaReleaseMbid *openapi_types.UUID `json:"caa_release_mbid,omitempty"`
	Date           *string             `json:"date,omitempty"`
	Name           *string             `json:"name,omitempty"`
	Rels           *[]Rels             `json:"rels,omitempty"`
	Type           *string             `json:"type,omitempty"`
}

// TopReleaseGroupsForArtistInnerReleaseGroup defines model for topReleaseGroupsForArtist_inner_release_group.
type TopReleaseGroupsForArtistInnerReleaseGroup struct {
	CaaId          *int                `json:"caa_id,omitempty"`
	CaaReleaseMbid *openapi_types.UUID `json:"caa_release_mbid,omitempty"`
	Date           *string             `json:"date,omitempty"`
	Name           *string             `json:"name,omitempty"`
	Rels           *[]Rels             `json:"rels,omitempty"`
	Type           *string             `json:"type,omitempty"`
}

// TopReleaseGroupsForArtistInnerTag defines model for topReleaseGroupsForArtist_inner_tag.
type TopReleaseGroupsForArtistInnerTag struct {
	Artist       *[]TopReleaseGroupsForArtistInnerTagArtistInner `json:"artist,omitempty"`
	ReleaseGroup *[]TopRecordingsForArtistInnerTagsInner         `json:"release_group,omitempty"`
}

// TopReleaseGroupsForArtistInnerTagArtistInner defines model for topReleaseGroupsForArtist_inner_tag_artist_inner.
type TopReleaseGroupsForArtistInnerTagArtistInner struct {
	ArtistMbid *openapi_types.UUID `json:"artist_mbid,omitempty"`
	Count      *int                `json:"count,omitempty"`
	GenreMbid  *openapi_types.UUID `json:"genre_mbid,omitempty"`
	Tag        *string             `json:"tag,omitempty"`
}

// TopReleaseGroupsForUser defines model for topReleaseGroupsForUser.
type TopReleaseGroupsForUser struct {
	Payload TopReleaseGroupsForUserPayload `json:"payload"`
}

// TopReleaseGroupsForUserPayload defines model for topReleaseGroupsForUser_payload.
type TopReleaseGroupsForUserPayload struct {
	Count                  int                  `json:"count"`
	FromTs                 int                  `json:"from_ts"`
	LastUpdated            int                  `json:"last_updated"`
	Offset                 int                  `json:"offset"`
	Range                  string               `json:"range"`
	ReleaseGroups          []ReleaseGroupsInner `json:"release_groups"`
	ToTs                   int                  `json:"to_ts"`
	TotalReleaseGroupCount int                  `json:"total_release_group_count"`
	UserId                 string               `json:"user_id"`
}

// TopReleasesForUser defines model for topReleasesForUser.
type TopReleasesForUser struct {
	Payload TopReleasesForUserPayload `json:"payload"`
}

// TopReleasesForUserPayload defines model for topReleasesForUser_payload.
type TopReleasesForUserPayload struct {
	Count             int                                      `json:"count"`
	FromTs            int                                      `json:"from_ts"`
	LastUpdated       int                                      `json:"last_updated"`
	Offset            int                                      `json:"offset"`
	Range             string                                   `json:"range"`
	Releases          []TopReleasesForUserPayloadReleasesInner `json:"releases"`
	ToTs              int                                      `json:"to_ts"`
	TotalReleaseCount int                                      `json:"total_release_count"`
	UserId            string                                   `json:"user_id"`
}

// TopReleasesForUserPayloadReleasesInner defines model for topReleasesForUser_payload_releases_inner.
type TopReleasesForUserPayloadReleasesInner struct {
	ArtistMbids    *[]openapi_types.UUID                                 `json:"artist_mbids,omitempty"`
	ArtistName     *string                                               `json:"artist_name,omitempty"`
	Artists        *[]TopReleasesForUserPayloadReleasesInnerArtistsInner `json:"artists,omitempty"`
	CaaId          *int                                                  `json:"caa_id,omitempty"`
	CaaReleaseMbid *openapi_types.UUID                                   `json:"caa_release_mbid,omitempty"`
	ListenCount    *int                                                  `json:"listen_count,omitempty"`
	ReleaseMbid    *openapi_types.UUID                                   `json:"release_mbid,omitempty"`
	ReleaseName    *string                                               `json:"release_name,omitempty"`
}

// TopReleasesForUserPayloadReleasesInnerArtistsInner defines model for topReleasesForUser_payload_releases_inner_artists_inner.
type TopReleasesForUserPayloadReleasesInnerArtistsInner struct {
	ArtistCreditName *string             `json:"artist_credit_name,omitempty"`
	ArtistMbid       *openapi_types.UUID `json:"artist_mbid,omitempty"`
	JoinPhrase       *string             `json:"join_phrase,omitempty"`
}

// TrackMetadata defines model for trackMetadata.
type TrackMetadata struct {
	AdditionalInfo       *AdditionalInfo                    `json:"additional_info,omitempty"`
	ArtistName           *string                            `json:"artist_name,omitempty"`
	BrainzplayerMetadata *TrackMetadataBrainzplayerMetadata `json:"brainzplayer_metadata,omitempty"`
	MbidMapping          *MbidMapping                       `json:"mbid_mapping,omitempty"`
	ReleaseName          *string                            `json:"release_name,omitempty"`
	TrackName            *string                            `json:"track_name,omitempty"`
}

// TrackMetadataBrainzplayerMetadata defines model for trackMetadata_brainzplayer_metadata.
type TrackMetadataBrainzplayerMetadata struct {
	ArtistName  *string `json:"artist_name,omitempty"`
	ReleaseName *string `json:"release_name,omitempty"`
	TrackName   *string `json:"track_name,omitempty"`
}

// UpdatePinRequest defines model for updatePin_request.
type UpdatePinRequest struct {
	BlurbContent *string `json:"blurb_content,omitempty"`
}

// ValidateToken defines model for validateToken.
type ValidateToken struct {
	Code     int     `json:"code"`
	Message  string  `json:"message"`
	UserName *string `json:"user_name,omitempty"`
	Valid    bool    `json:"valid"`
}

// YearInMusicForUser defines model for yearInMusicForUser.
type YearInMusicForUser struct {
	Payload YearInMusicForUserPayload `json:"payload"`
}

// YearInMusicForUserPayload defines model for yearInMusicForUser_payload.
type YearInMusicForUserPayload struct {
	Data     YearInMusicForUserPayloadData `json:"data"`
	UserName string                        `json:"user_name"`
}

// YearInMusicForUserPayloadData defines model for yearInMusicForUser_payload_data.
type YearInMusicForUserPayloadData struct {
	ArtistMap                          []ArtistMapForUserPayloadArtistMapInner                     `json:"artist_map"`
	DayOfWeek                          string                                                      `json:"day_of_week"`
	ListensPerDay                      []ListeningActivityForUserPayloadListeningActivityInner     `json:"listens_per_day"`
	MostListenedYear                   map[string]int                                              `json:"most_listened_year"`
	NewReleasesOfTopArtists            []YearInMusicForUserPayloadDataNewReleasesOfTopArtistsInner `json:"new_releases_of_top_artists"`
	PlaylistTopDiscoveriesForYear      Playlist                                                    `json:"playlist-top-discoveries-for-year"`
	PlaylistTopMissedRecordingsForYear Playlist                                                    `json:"playlist-top-missed-recordings-for-year"`
	SimilarUsers                       map[string]int                                              `json:"similar_users"`
	TopArtists                         []TopArtistsForUserPayloadArtistsInner                      `json:"top_artists"`
	TopGenres                          []YearInMusicForUserPayloadDataTopGenresInner               `json:"top_genres"`
	TopRecordings                      []TopRecordingsForUserPayloadRecordingsInner                `json:"top_recordings"`
	TopReleaseGroups                   []ReleaseGroupsInner                                        `json:"top_release_groups"`
	TotalArtistsCount                  int                                                         `json:"total_artists_count"`
	TotalListenCount                   int                                                         `json:"total_listen_count"`
	TotalListeningTime                 int                                                         `json:"total_listening_time"`
	TotalNewArtistsDiscovered          int                                                         `json:"total_new_artists_discovered"`
	TotalRecordingsCount               int                                                         `json:"total_recordings_count"`
	TotalReleaseGroupsCount            int                                                         `json:"total_release_groups_count"`
}

// YearInMusicForUserPayloadDataNewReleasesOfTopArtistsInner defines model for yearInMusicForUser_payload_data_new_releases_of_top_artists_inner.
type YearInMusicForUserPayloadDataNewReleasesOfTopArtistsInner struct {
	ArtistCreditMbids *[]openapi_types.UUID                                 `json:"artist_credit_mbids,omitempty"`
	ArtistCreditName  *string                                               `json:"artist_credit_name,omitempty"`
	Artists           *[]TopReleasesForUserPayloadReleasesInnerArtistsInner `json:"artists,omitempty"`
	CaaId             *int                                                  `json:"caa_id,omitempty"`
	CaaReleaseMbid    *openapi_types.UUID                                   `json:"caa_release_mbid,omitempty"`
	ReleaseGroupMbid  *openapi_types.UUID                                   `json:"release_group_mbid,omitempty"`
	Title             *string                                               `json:"title,omitempty"`
}

// YearInMusicForUserPayloadDataTopGenresInner defines model for yearInMusicForUser_payload_data_top_genres_inner.
type YearInMusicForUserPayloadDataTopGenresInner struct {
	Genre             *string `json:"genre,omitempty"`
	GenreCount        *int    `json:"genre_count,omitempty"`
	GenreCountPercent *int    `json:"genre_count_percent,omitempty"`
}

// YearInMusicParams defines parameters for YearInMusic.
type YearInMusicParams struct {
	Image YearInMusicImage `form:"image" json:"image"`
}

// RecordingRecommendationsParams defines parameters for RecordingRecommendations.
type RecordingRecommendationsParams struct {
	// Count Optional, number of recording mbids to return.
	Count *int `form:"count,omitempty" json:"count,omitempty"`

	// Offset Optional, number of mbids to skip from the beginning, for pagination. Ex. An offset of 5 means the 5 mbids will be skipped.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// FreshReleasesParams defines parameters for FreshReleases.
type FreshReleasesParams struct {
	// ReleaseDate Fresh releases will be shown around this pivot date. Must be in YYYY-MM-DD format.
	ReleaseDate *string `form:"release_date,omitempty" json:"release_date,omitempty"`

	// Days The number of days of fresh releases to show. Max 90 days.
	Days *int `form:"days,omitempty" json:"days,omitempty"`

	// Sort The sort order of the results.
	Sort *FreshReleasesParamsSort `form:"sort,omitempty" json:"sort,omitempty"`

	// Past Whether to show releases in the past.
	Past *bool `form:"past,omitempty" json:"past,omitempty"`

	// Future Whether to show releases in the future.
	Future *bool `form:"future,omitempty" json:"future,omitempty"`
}

// FreshReleasesParamsSort defines parameters for FreshReleases.
type FreshReleasesParamsSort string

// LbRadioParams defines parameters for LbRadio.
type LbRadioParams struct {
	// Prompt The LB Radio prompt from which to generate playlists.
	Prompt string `form:"prompt" json:"prompt"`

	// Mode The mode that LB radio should use. Must be easy, medium or hard.
	Mode Mode `form:"mode" json:"mode"`
}

// GetFeedbackMbidParams defines parameters for GetFeedbackMbid.
type GetFeedbackMbidParams struct {
	Score  *int `form:"score,omitempty" json:"score,omitempty"`
	Count  *int `form:"count,omitempty" json:"count,omitempty"`
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetFeedbackMsidParams defines parameters for GetFeedbackMsid.
type GetFeedbackMsidParams struct {
	Score  *int `form:"score,omitempty" json:"score,omitempty"`
	Count  *int `form:"count,omitempty" json:"count,omitempty"`
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetFeedbackParams defines parameters for GetFeedback.
type GetFeedbackParams struct {
	Score    *int    `form:"score,omitempty" json:"score,omitempty"`
	Count    *int    `form:"count,omitempty" json:"count,omitempty"`
	Offset   *int    `form:"offset,omitempty" json:"offset,omitempty"`
	Metadata *string `form:"metadata,omitempty" json:"metadata,omitempty"`
}

// GetFeedbackForRecordingsParams defines parameters for GetFeedbackForRecordings.
type GetFeedbackForRecordingsParams struct {
	// RecordingMsids Comma separated list of recording_msids for which feedback records are to be fetched.
	RecordingMsids *[]openapi_types.UUID `form:"recording_msids,omitempty" json:"recording_msids,omitempty"`

	// RecordingMbids Comma separated list of recording_mbids for which feedback records are to be fetched.
	RecordingMbids *[]openapi_types.UUID `form:"recording_mbids,omitempty" json:"recording_mbids,omitempty"`
}

// LatestImportParams defines parameters for LatestImport.
type LatestImportParams struct {
	// UserName The MusicBrainz ID of the user whose data is needed.
	UserName string `form:"user_name" json:"user_name"`
}

// LbRadioRecordingsForArtistParams defines parameters for LbRadioRecordingsForArtist.
type LbRadioRecordingsForArtistParams struct {
	// Mode The mode that LB radio should use. Must be easy, medium or hard.
	Mode Mode `form:"mode" json:"mode"`

	// MaxSimilarArtists The maximum number of similar artists to return recordings for.
	MaxSimilarArtists int `form:"max_similar_artists" json:"max_similar_artists"`

	// MaxRecordingsPerArtist The maximum number of recordings to return for each artist. If there are arent enough recordings, all available recordings will be returned.
	MaxRecordingsPerArtist int `form:"max_recordings_per_artist" json:"max_recordings_per_artist"`

	// PopBegin Popularity range percentage lower bound. A popularity range is given to narrow down the recordings into a smaller target group. The most popular recording(s) on LB have a pop percent of 100. The least popular recordings have a score of 0. This range is not coupled to the specified mode, but the mode would often determine the popularity range, so that less popular recordings can be returned on the medium and harder modes.
	PopBegin int `form:"pop_begin" json:"pop_begin"`

	// PopEnd Popularity range percentage upper bound.
	PopEnd int `form:"pop_end" json:"pop_end"`
}

// LbRadioTagsParams defines parameters for LbRadioTags.
type LbRadioTagsParams struct {
	// Tag The MusicBrainz tag to fetch recordings for, this parameter can be specified multiple times. if more than one tag is specified, the operator param should also be specified.
	Tag string `form:"tag" json:"tag"`

	// Operator Specify AND to retrieve recordings that have all the tags, otherwise specify OR to retrieve recordings that have any one of the tags.
	Operator *Operator `form:"operator,omitempty" json:"operator,omitempty"`

	// PopBegin Popularity range percentage lower bound. A popularity range is given to narrow down the recordings into a smaller target group. The most popular recording(s) on LB have a pop percent of 100. The least popular recordings have a score of 0. This range is not coupled to the specified mode, but the mode would often determine the popularity range, so that less popular recordings can be returned on the medium and harder modes.
	PopBegin int `form:"pop_begin" json:"pop_begin"`

	// PopEnd Popularity range percentage upper bound.
	PopEnd int `form:"pop_end" json:"pop_end"`

	// Count Optional, number of listens to return.
	Count int `form:"count" json:"count"`
}

// ArtistMetadataParams defines parameters for ArtistMetadata.
type ArtistMetadataParams struct {
	// ArtistMbids A comma separated list of recording_mbids.
	ArtistMbids []openapi_types.UUID `form:"artist_mbids" json:"artist_mbids"`

	// Inc A space separated list of artist, tag and/or release to indicate which portions of metadata you're interested in fetching. We encourage users to only fetch the data they plan to consume.
	Inc string `form:"inc" json:"inc"`
}

// GetManualMappingParams defines parameters for GetManualMapping.
type GetManualMappingParams struct {
	RecordingMsid openapi_types.UUID `form:"recording_msid" json:"recording_msid"`
}

// LookupParams defines parameters for Lookup.
type LookupParams struct {
	// ArtistName Artist name of the listen.
	ArtistName string `form:"artist_name" json:"artist_name"`

	// RecordingName Track name of the listen.
	RecordingName string `form:"recording_name" json:"recording_name"`

	// ReleaseName Release name of the listen.
	ReleaseName *string `form:"release_name,omitempty" json:"release_name,omitempty"`

	// Metadata Should extra metadata be also returned if a match is found, see /metadata/recording for details.
	Metadata bool `form:"metadata" json:"metadata"`

	// Inc A space separated list of artist, tag and/or release to indicate which portions of metadata you're interested in fetching. We encourage users to only fetch the data they plan to consume.
	Inc string `form:"inc" json:"inc"`
}

// RecordingMetadataParams defines parameters for RecordingMetadata.
type RecordingMetadataParams struct {
	// RecordingMbids A comma separated list of recording_mbids.
	RecordingMbids []openapi_types.UUID `form:"recording_mbids" json:"recording_mbids"`

	// Inc A space separated list of artist, tag and/or release to indicate which portions of metadata you're interested in fetching. We encourage users to only fetch the data they plan to consume.
	Inc string `form:"inc" json:"inc"`
}

// ReleaseGroupMetadataParams defines parameters for ReleaseGroupMetadata.
type ReleaseGroupMetadataParams struct {
	// ReleaseGroupMbids A comma separated list of release_group_mbids.
	ReleaseGroupMbids []openapi_types.UUID `form:"release_group_mbids" json:"release_group_mbids"`

	// Inc A space separated list of artist, tag and/or release to indicate which portions of metadata you're interested in fetching. We encourage users to only fetch the data they plan to consume.
	Inc string `form:"inc" json:"inc"`
}

// SearchPlaylistsParams defines parameters for SearchPlaylists.
type SearchPlaylistsParams struct {
	Query string `form:"query" json:"query"`
}

// FetchPlaylistParams defines parameters for FetchPlaylist.
type FetchPlaylistParams struct {
	// FetchMetadata Optional, pass value false' to skip lookup up recording metadata.
	FetchMetadata *bool `form:"fetch_metadata,omitempty" json:"fetch_metadata,omitempty"`
}

// FeedbackGivenByParams defines parameters for FeedbackGivenBy.
type FeedbackGivenByParams struct {
	// Rating Optional, refer to db/model/recommendation_feedback.py for allowed rating values.
	Rating *string `form:"rating,omitempty" json:"rating,omitempty"`

	// Count Optional, number of recording mbids to return.
	Count *int `form:"count,omitempty" json:"count,omitempty"`

	// Offset Optional, number of mbids to skip from the beginning, for pagination. Ex. An offset of 5 means the 5 mbids will be skipped.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// RecordingsFeedbackGivenByParams defines parameters for RecordingsFeedbackGivenBy.
type RecordingsFeedbackGivenByParams struct {
	// Mbids Comma separated list of recording_mbids for which feedback records are to be fetched.
	Mbids []openapi_types.UUID `form:"mbids" json:"mbids"`
}

// SearchUsersParams defines parameters for SearchUsers.
type SearchUsersParams struct {
	// SearchTerm Input on which search operation is to be performed.
	SearchTerm string `form:"search_term" json:"search_term"`
}

// ListenersForArtistParams defines parameters for ListenersForArtist.
type ListenersForArtistParams struct {
	Range *AllowedStatisticsRange `form:"range,omitempty" json:"range,omitempty"`
}

// ListenersForReleaseGroupParams defines parameters for ListenersForReleaseGroup.
type ListenersForReleaseGroupParams struct {
	Range *AllowedStatisticsRange `form:"range,omitempty" json:"range,omitempty"`
}

// SitewideArtistMapParams defines parameters for SitewideArtistMap.
type SitewideArtistMapParams struct {
	Range *AllowedStatisticsRange `form:"range,omitempty" json:"range,omitempty"`

	// ForceRecalculate Optional, recalculate the data instead of returning the cached result.
	ForceRecalculate *bool `form:"force_recalculate,omitempty" json:"force_recalculate,omitempty"`
}

// SitewideTopArtistsParams defines parameters for SitewideTopArtists.
type SitewideTopArtistsParams struct {
	Count  *int                    `form:"count,omitempty" json:"count,omitempty"`
	Offset *int                    `form:"offset,omitempty" json:"offset,omitempty"`
	Range  *AllowedStatisticsRange `form:"range,omitempty" json:"range,omitempty"`
}

// SitewideListeningActivityParams defines parameters for SitewideListeningActivity.
type SitewideListeningActivityParams struct {
	Range *AllowedStatisticsRange `form:"range,omitempty" json:"range,omitempty"`
}

// SitewideTopRecordingsParams defines parameters for SitewideTopRecordings.
type SitewideTopRecordingsParams struct {
	Count  *int                    `form:"count,omitempty" json:"count,omitempty"`
	Offset *int                    `form:"offset,omitempty" json:"offset,omitempty"`
	Range  *AllowedStatisticsRange `form:"range,omitempty" json:"range,omitempty"`
}

// SitewideTopReleaseGroupsParams defines parameters for SitewideTopReleaseGroups.
type SitewideTopReleaseGroupsParams struct {
	Count  *int                    `form:"count,omitempty" json:"count,omitempty"`
	Offset *int                    `form:"offset,omitempty" json:"offset,omitempty"`
	Range  *AllowedStatisticsRange `form:"range,omitempty" json:"range,omitempty"`
}

// SitewideTopReleasesParams defines parameters for SitewideTopReleases.
type SitewideTopReleasesParams struct {
	Count  *int                    `form:"count,omitempty" json:"count,omitempty"`
	Offset *int                    `form:"offset,omitempty" json:"offset,omitempty"`
	Range  *AllowedStatisticsRange `form:"range,omitempty" json:"range,omitempty"`
}

// ArtistMapForUserParams defines parameters for ArtistMapForUser.
type ArtistMapForUserParams struct {
	Range *AllowedStatisticsRange `form:"range,omitempty" json:"range,omitempty"`

	// ForceRecalculate Optional, recalculate the data instead of returning the cached result.
	ForceRecalculate *bool `form:"force_recalculate,omitempty" json:"force_recalculate,omitempty"`
}

// TopArtistsForUserParams defines parameters for TopArtistsForUser.
type TopArtistsForUserParams struct {
	Count  *int                    `form:"count,omitempty" json:"count,omitempty"`
	Offset *int                    `form:"offset,omitempty" json:"offset,omitempty"`
	Range  *AllowedStatisticsRange `form:"range,omitempty" json:"range,omitempty"`
}

// DailyActivityForUserParams defines parameters for DailyActivityForUser.
type DailyActivityForUserParams struct {
	Range *AllowedStatisticsRange `form:"range,omitempty" json:"range,omitempty"`
}

// ListeningActivityForUserParams defines parameters for ListeningActivityForUser.
type ListeningActivityForUserParams struct {
	Range *AllowedStatisticsRange `form:"range,omitempty" json:"range,omitempty"`
}

// TopRecordingsForUserParams defines parameters for TopRecordingsForUser.
type TopRecordingsForUserParams struct {
	Count  *int                    `form:"count,omitempty" json:"count,omitempty"`
	Offset *int                    `form:"offset,omitempty" json:"offset,omitempty"`
	Range  *AllowedStatisticsRange `form:"range,omitempty" json:"range,omitempty"`
}

// TopReleaseGroupsForUserParams defines parameters for TopReleaseGroupsForUser.
type TopReleaseGroupsForUserParams struct {
	Count  *int                    `form:"count,omitempty" json:"count,omitempty"`
	Offset *int                    `form:"offset,omitempty" json:"offset,omitempty"`
	Range  *AllowedStatisticsRange `form:"range,omitempty" json:"range,omitempty"`
}

// TopReleasesForUserParams defines parameters for TopReleasesForUser.
type TopReleasesForUserParams struct {
	Count  *int                    `form:"count,omitempty" json:"count,omitempty"`
	Offset *int                    `form:"offset,omitempty" json:"offset,omitempty"`
	Range  *AllowedStatisticsRange `form:"range,omitempty" json:"range,omitempty"`
}

// GetDumpInfoParams defines parameters for GetDumpInfo.
type GetDumpInfoParams struct {
	// Id Integer specifying the ID of the dump, if not provided, the endpoint returns information about the latest data dump.
	Id *int `form:"id,omitempty" json:"id,omitempty"`
}

// PlaylistsForUserParams defines parameters for PlaylistsForUser.
type PlaylistsForUserParams struct {
	Count  *int `form:"count,omitempty" json:"count,omitempty"`
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// PlaylistsForUserCollaboratorParams defines parameters for PlaylistsForUserCollaborator.
type PlaylistsForUserCollaboratorParams struct {
	Count  *int `form:"count,omitempty" json:"count,omitempty"`
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// PlaylistsCreatedForUserParams defines parameters for PlaylistsCreatedForUser.
type PlaylistsCreatedForUserParams struct {
	Count  *int `form:"count,omitempty" json:"count,omitempty"`
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// SearchPlaylistForUserParams defines parameters for SearchPlaylistForUser.
type SearchPlaylistForUserParams struct {
	Query string `form:"query" json:"query"`

	// Count The number of playlists to return (for pagination).
	Count *int `form:"count,omitempty" json:"count,omitempty"`

	// Offset The offset of into the list of playlists to return (for pagination).
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// FeedEventsParams defines parameters for FeedEvents.
type FeedEventsParams struct {
	// MaxTs If you specify a 'max_ts' timestamp, events with timestamps less than the value will be returned.
	MaxTs *int `form:"max_ts,omitempty" json:"max_ts,omitempty"`

	// MinTs If you specify a 'min_ts' timestamp, events with timestamps greater than the value will be returned.
	MinTs *int `form:"min_ts,omitempty" json:"min_ts,omitempty"`
	Count *int `form:"count,omitempty" json:"count,omitempty"`
}

// FeedEventsListensFollowingParams defines parameters for FeedEventsListensFollowing.
type FeedEventsListensFollowingParams struct {
	// MaxTs If you specify a 'max_ts' timestamp, events with timestamps less than the value will be returned.
	MaxTs *int `form:"max_ts,omitempty" json:"max_ts,omitempty"`

	// MinTs If you specify a 'min_ts' timestamp, events with timestamps greater than the value will be returned.
	MinTs *int `form:"min_ts,omitempty" json:"min_ts,omitempty"`
	Count *int `form:"count,omitempty" json:"count,omitempty"`
}

// FeedEventsListensSimilarParams defines parameters for FeedEventsListensSimilar.
type FeedEventsListensSimilarParams struct {
	// MaxTs If you specify a 'max_ts' timestamp, events with timestamps less than the value will be returned.
	MaxTs *int `form:"max_ts,omitempty" json:"max_ts,omitempty"`

	// MinTs If you specify a 'min_ts' timestamp, events with timestamps greater than the value will be returned.
	MinTs *int `form:"min_ts,omitempty" json:"min_ts,omitempty"`
	Count *int `form:"count,omitempty" json:"count,omitempty"`
}

// ListensForUserParams defines parameters for ListensForUser.
type ListensForUserParams struct {
	// MaxTs If you specify a 'max_ts' timestamp, listens with listened_at less than (but not including) this value will be returned.
	MaxTs *int `form:"max_ts,omitempty" json:"max_ts,omitempty"`

	// MinTs If you specify a 'min_ts' timestamp, listens with listened_at greater than (but not including) this value will be returned.
	MinTs *int `form:"min_ts,omitempty" json:"min_ts,omitempty"`

	// Count Optional, number of listens to return.
	Count *int `form:"count,omitempty" json:"count,omitempty"`
}

// GetPinsParams defines parameters for GetPins.
type GetPinsParams struct {
	Count  *int `form:"count,omitempty" json:"count,omitempty"`
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetPinsFollowingParams defines parameters for GetPinsFollowing.
type GetPinsFollowingParams struct {
	Count  *int `form:"count,omitempty" json:"count,omitempty"`
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// CreateCoverArtGridJSONRequestBody defines body for CreateCoverArtGrid for application/json ContentType.
type CreateCoverArtGridJSONRequestBody = CreateCoverArtGrid

// DeleteListenJSONRequestBody defines body for DeleteListen for application/json ContentType.
type DeleteListenJSONRequestBody = DeleteListen

// RecordingFeedbackJSONRequestBody defines body for RecordingFeedback for application/json ContentType.
type RecordingFeedbackJSONRequestBody = RecordingFeedbackRequest

// SubmitManualMappingJSONRequestBody defines body for SubmitManualMapping for application/json ContentType.
type SubmitManualMappingJSONRequestBody = SubmitManualMapping

// PinJSONRequestBody defines body for Pin for application/json ContentType.
type PinJSONRequestBody = PinRequest

// UpdatePinJSONRequestBody defines body for UpdatePin for application/json ContentType.
type UpdatePinJSONRequestBody = UpdatePinRequest

// CreatePlaylistJSONRequestBody defines body for CreatePlaylist for application/json ContentType.
type CreatePlaylistJSONRequestBody = CreatePlaylistRequest

// EditPlaylistJSONRequestBody defines body for EditPlaylist for application/json ContentType.
type EditPlaylistJSONRequestBody = CreatePlaylistRequest

// AppendRecordingsJSONRequestBody defines body for AppendRecordings for application/json ContentType.
type AppendRecordingsJSONRequestBody = Playlist

// ItemDeleteJSONRequestBody defines body for ItemDelete for application/json ContentType.
type ItemDeleteJSONRequestBody = ItemDeleteRequest

// MoveItemJSONRequestBody defines body for MoveItem for application/json ContentType.
type MoveItemJSONRequestBody = MoveItemRequest

// ArtistJSONRequestBody defines body for Artist for application/json ContentType.
type ArtistJSONRequestBody = ArtistRequest

// RecordingJSONRequestBody defines body for Recording for application/json ContentType.
type RecordingJSONRequestBody = RecordingRequest

// ReleaseJSONRequestBody defines body for Release for application/json ContentType.
type ReleaseJSONRequestBody = ReleaseRequest

// ReleaseGroupJSONRequestBody defines body for ReleaseGroup for application/json ContentType.
type ReleaseGroupJSONRequestBody = ReleaseGroupRequest

// SubmitFeedbackJSONRequestBody defines body for SubmitFeedback for application/json ContentType.
type SubmitFeedbackJSONRequestBody = SubmitFeedbackRequest

// DeleteFeedbackJSONRequestBody defines body for DeleteFeedback for application/json ContentType.
type DeleteFeedbackJSONRequestBody = DeleteFeedbackRequest

// SubmitListensJSONRequestBody defines body for SubmitListens for application/json ContentType.
type SubmitListensJSONRequestBody = SubmitListens

// FeedEventsDeleteJSONRequestBody defines body for FeedEventsDelete for application/json ContentType.
type FeedEventsDeleteJSONRequestBody = FeedEventsDeleteRequest

// FeedEventsHideJSONRequestBody defines body for FeedEventsHide for application/json ContentType.
type FeedEventsHideJSONRequestBody = FeedEventsDeleteRequest

// FeedEventsUnhideJSONRequestBody defines body for FeedEventsUnhide for application/json ContentType.
type FeedEventsUnhideJSONRequestBody = FeedEventsDeleteRequest

// CreateNotificationJSONRequestBody defines body for CreateNotification for application/json ContentType.
type CreateNotificationJSONRequestBody = CreateNotificationRequest

// RecommendPersonalRecordingJSONRequestBody defines body for RecommendPersonalRecording for application/json ContentType.
type RecommendPersonalRecordingJSONRequestBody = RecommendPersonalRecordingRequest

// RecommendRecordingJSONRequestBody defines body for RecommendRecording for application/json ContentType.
type RecommendRecordingJSONRequestBody = RecommendRecordingRequest

// CreateReviewJSONRequestBody defines body for CreateReview for application/json ContentType.
type CreateReviewJSONRequestBody = CreateReviewRequest

// Getter for additional properties for AdditionalInfo. Returns the specified
// element and whether it was found
func (a AdditionalInfo) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for AdditionalInfo
func (a *AdditionalInfo) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for AdditionalInfo to handle AdditionalProperties
func (a *AdditionalInfo) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["albumartist"]; found {
		err = json.Unmarshal(raw, &a.Albumartist)
		if err != nil {
			return fmt.Errorf("error reading 'albumartist': %w", err)
		}
		delete(object, "albumartist")
	}

	if raw, found := object["artist_mbids"]; found {
		err = json.Unmarshal(raw, &a.ArtistMbids)
		if err != nil {
			return fmt.Errorf("error reading 'artist_mbids': %w", err)
		}
		delete(object, "artist_mbids")
	}

	if raw, found := object["artist_names"]; found {
		err = json.Unmarshal(raw, &a.ArtistNames)
		if err != nil {
			return fmt.Errorf("error reading 'artist_names': %w", err)
		}
		delete(object, "artist_names")
	}

	if raw, found := object["comment"]; found {
		err = json.Unmarshal(raw, &a.Comment)
		if err != nil {
			return fmt.Errorf("error reading 'comment': %w", err)
		}
		delete(object, "comment")
	}

	if raw, found := object["date"]; found {
		err = json.Unmarshal(raw, &a.Date)
		if err != nil {
			return fmt.Errorf("error reading 'date': %w", err)
		}
		delete(object, "date")
	}

	if raw, found := object["discnumber"]; found {
		err = json.Unmarshal(raw, &a.Discnumber)
		if err != nil {
			return fmt.Errorf("error reading 'discnumber': %w", err)
		}
		delete(object, "discnumber")
	}

	if raw, found := object["duration"]; found {
		err = json.Unmarshal(raw, &a.Duration)
		if err != nil {
			return fmt.Errorf("error reading 'duration': %w", err)
		}
		delete(object, "duration")
	}

	if raw, found := object["duration_ms"]; found {
		err = json.Unmarshal(raw, &a.DurationMs)
		if err != nil {
			return fmt.Errorf("error reading 'duration_ms': %w", err)
		}
		delete(object, "duration_ms")
	}

	if raw, found := object["genre"]; found {
		err = json.Unmarshal(raw, &a.Genre)
		if err != nil {
			return fmt.Errorf("error reading 'genre': %w", err)
		}
		delete(object, "genre")
	}

	if raw, found := object["isrc"]; found {
		err = json.Unmarshal(raw, &a.Isrc)
		if err != nil {
			return fmt.Errorf("error reading 'isrc': %w", err)
		}
		delete(object, "isrc")
	}

	if raw, found := object["listening_from"]; found {
		err = json.Unmarshal(raw, &a.ListeningFrom)
		if err != nil {
			return fmt.Errorf("error reading 'listening_from': %w", err)
		}
		delete(object, "listening_from")
	}

	if raw, found := object["media_player"]; found {
		err = json.Unmarshal(raw, &a.MediaPlayer)
		if err != nil {
			return fmt.Errorf("error reading 'media_player': %w", err)
		}
		delete(object, "media_player")
	}

	if raw, found := object["media_player_version"]; found {
		err = json.Unmarshal(raw, &a.MediaPlayerVersion)
		if err != nil {
			return fmt.Errorf("error reading 'media_player_version': %w", err)
		}
		delete(object, "media_player_version")
	}

	if raw, found := object["music_service"]; found {
		err = json.Unmarshal(raw, &a.MusicService)
		if err != nil {
			return fmt.Errorf("error reading 'music_service': %w", err)
		}
		delete(object, "music_service")
	}

	if raw, found := object["music_service_name"]; found {
		err = json.Unmarshal(raw, &a.MusicServiceName)
		if err != nil {
			return fmt.Errorf("error reading 'music_service_name': %w", err)
		}
		delete(object, "music_service_name")
	}

	if raw, found := object["origin_url"]; found {
		err = json.Unmarshal(raw, &a.OriginUrl)
		if err != nil {
			return fmt.Errorf("error reading 'origin_url': %w", err)
		}
		delete(object, "origin_url")
	}

	if raw, found := object["recording_mbid"]; found {
		err = json.Unmarshal(raw, &a.RecordingMbid)
		if err != nil {
			return fmt.Errorf("error reading 'recording_mbid': %w", err)
		}
		delete(object, "recording_mbid")
	}

	if raw, found := object["recording_msid"]; found {
		err = json.Unmarshal(raw, &a.RecordingMsid)
		if err != nil {
			return fmt.Errorf("error reading 'recording_msid': %w", err)
		}
		delete(object, "recording_msid")
	}

	if raw, found := object["release_artist_name"]; found {
		err = json.Unmarshal(raw, &a.ReleaseArtistName)
		if err != nil {
			return fmt.Errorf("error reading 'release_artist_name': %w", err)
		}
		delete(object, "release_artist_name")
	}

	if raw, found := object["release_artist_names"]; found {
		err = json.Unmarshal(raw, &a.ReleaseArtistNames)
		if err != nil {
			return fmt.Errorf("error reading 'release_artist_names': %w", err)
		}
		delete(object, "release_artist_names")
	}

	if raw, found := object["release_group_mbid"]; found {
		err = json.Unmarshal(raw, &a.ReleaseGroupMbid)
		if err != nil {
			return fmt.Errorf("error reading 'release_group_mbid': %w", err)
		}
		delete(object, "release_group_mbid")
	}

	if raw, found := object["release_mbid"]; found {
		err = json.Unmarshal(raw, &a.ReleaseMbid)
		if err != nil {
			return fmt.Errorf("error reading 'release_mbid': %w", err)
		}
		delete(object, "release_mbid")
	}

	if raw, found := object["spotify_album_artist_ids"]; found {
		err = json.Unmarshal(raw, &a.SpotifyAlbumArtistIds)
		if err != nil {
			return fmt.Errorf("error reading 'spotify_album_artist_ids': %w", err)
		}
		delete(object, "spotify_album_artist_ids")
	}

	if raw, found := object["spotify_album_id"]; found {
		err = json.Unmarshal(raw, &a.SpotifyAlbumId)
		if err != nil {
			return fmt.Errorf("error reading 'spotify_album_id': %w", err)
		}
		delete(object, "spotify_album_id")
	}

	if raw, found := object["spotify_artist_ids"]; found {
		err = json.Unmarshal(raw, &a.SpotifyArtistIds)
		if err != nil {
			return fmt.Errorf("error reading 'spotify_artist_ids': %w", err)
		}
		delete(object, "spotify_artist_ids")
	}

	if raw, found := object["spotify_id"]; found {
		err = json.Unmarshal(raw, &a.SpotifyId)
		if err != nil {
			return fmt.Errorf("error reading 'spotify_id': %w", err)
		}
		delete(object, "spotify_id")
	}

	if raw, found := object["submission_client"]; found {
		err = json.Unmarshal(raw, &a.SubmissionClient)
		if err != nil {
			return fmt.Errorf("error reading 'submission_client': %w", err)
		}
		delete(object, "submission_client")
	}

	if raw, found := object["submission_client_version"]; found {
		err = json.Unmarshal(raw, &a.SubmissionClientVersion)
		if err != nil {
			return fmt.Errorf("error reading 'submission_client_version': %w", err)
		}
		delete(object, "submission_client_version")
	}

	if raw, found := object["tags"]; found {
		err = json.Unmarshal(raw, &a.Tags)
		if err != nil {
			return fmt.Errorf("error reading 'tags': %w", err)
		}
		delete(object, "tags")
	}

	if raw, found := object["trackNumber"]; found {
		err = json.Unmarshal(raw, &a.TrackNumber)
		if err != nil {
			return fmt.Errorf("error reading 'trackNumber': %w", err)
		}
		delete(object, "trackNumber")
	}

	if raw, found := object["track_mbid"]; found {
		err = json.Unmarshal(raw, &a.TrackMbid)
		if err != nil {
			return fmt.Errorf("error reading 'track_mbid': %w", err)
		}
		delete(object, "track_mbid")
	}

	if raw, found := object["tracknumber"]; found {
		err = json.Unmarshal(raw, &a.Tracknumber)
		if err != nil {
			return fmt.Errorf("error reading 'tracknumber': %w", err)
		}
		delete(object, "tracknumber")
	}

	if raw, found := object["work_mbids"]; found {
		err = json.Unmarshal(raw, &a.WorkMbids)
		if err != nil {
			return fmt.Errorf("error reading 'work_mbids': %w", err)
		}
		delete(object, "work_mbids")
	}

	if raw, found := object["youtube_id"]; found {
		err = json.Unmarshal(raw, &a.YoutubeId)
		if err != nil {
			return fmt.Errorf("error reading 'youtube_id': %w", err)
		}
		delete(object, "youtube_id")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for AdditionalInfo to handle AdditionalProperties
func (a AdditionalInfo) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Albumartist != nil {
		object["albumartist"], err = json.Marshal(a.Albumartist)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'albumartist': %w", err)
		}
	}

	if a.ArtistMbids != nil {
		object["artist_mbids"], err = json.Marshal(a.ArtistMbids)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'artist_mbids': %w", err)
		}
	}

	if a.ArtistNames != nil {
		object["artist_names"], err = json.Marshal(a.ArtistNames)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'artist_names': %w", err)
		}
	}

	if a.Comment != nil {
		object["comment"], err = json.Marshal(a.Comment)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'comment': %w", err)
		}
	}

	if a.Date != nil {
		object["date"], err = json.Marshal(a.Date)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'date': %w", err)
		}
	}

	if a.Discnumber != nil {
		object["discnumber"], err = json.Marshal(a.Discnumber)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'discnumber': %w", err)
		}
	}

	if a.Duration != nil {
		object["duration"], err = json.Marshal(a.Duration)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'duration': %w", err)
		}
	}

	if a.DurationMs != nil {
		object["duration_ms"], err = json.Marshal(a.DurationMs)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'duration_ms': %w", err)
		}
	}

	if a.Genre != nil {
		object["genre"], err = json.Marshal(a.Genre)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'genre': %w", err)
		}
	}

	if a.Isrc != nil {
		object["isrc"], err = json.Marshal(a.Isrc)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'isrc': %w", err)
		}
	}

	if a.ListeningFrom != nil {
		object["listening_from"], err = json.Marshal(a.ListeningFrom)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'listening_from': %w", err)
		}
	}

	if a.MediaPlayer != nil {
		object["media_player"], err = json.Marshal(a.MediaPlayer)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'media_player': %w", err)
		}
	}

	if a.MediaPlayerVersion != nil {
		object["media_player_version"], err = json.Marshal(a.MediaPlayerVersion)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'media_player_version': %w", err)
		}
	}

	if a.MusicService != nil {
		object["music_service"], err = json.Marshal(a.MusicService)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'music_service': %w", err)
		}
	}

	if a.MusicServiceName != nil {
		object["music_service_name"], err = json.Marshal(a.MusicServiceName)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'music_service_name': %w", err)
		}
	}

	if a.OriginUrl != nil {
		object["origin_url"], err = json.Marshal(a.OriginUrl)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'origin_url': %w", err)
		}
	}

	if a.RecordingMbid != nil {
		object["recording_mbid"], err = json.Marshal(a.RecordingMbid)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'recording_mbid': %w", err)
		}
	}

	if a.RecordingMsid != nil {
		object["recording_msid"], err = json.Marshal(a.RecordingMsid)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'recording_msid': %w", err)
		}
	}

	if a.ReleaseArtistName != nil {
		object["release_artist_name"], err = json.Marshal(a.ReleaseArtistName)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'release_artist_name': %w", err)
		}
	}

	if a.ReleaseArtistNames != nil {
		object["release_artist_names"], err = json.Marshal(a.ReleaseArtistNames)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'release_artist_names': %w", err)
		}
	}

	if a.ReleaseGroupMbid != nil {
		object["release_group_mbid"], err = json.Marshal(a.ReleaseGroupMbid)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'release_group_mbid': %w", err)
		}
	}

	if a.ReleaseMbid != nil {
		object["release_mbid"], err = json.Marshal(a.ReleaseMbid)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'release_mbid': %w", err)
		}
	}

	if a.SpotifyAlbumArtistIds != nil {
		object["spotify_album_artist_ids"], err = json.Marshal(a.SpotifyAlbumArtistIds)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'spotify_album_artist_ids': %w", err)
		}
	}

	if a.SpotifyAlbumId != nil {
		object["spotify_album_id"], err = json.Marshal(a.SpotifyAlbumId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'spotify_album_id': %w", err)
		}
	}

	if a.SpotifyArtistIds != nil {
		object["spotify_artist_ids"], err = json.Marshal(a.SpotifyArtistIds)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'spotify_artist_ids': %w", err)
		}
	}

	if a.SpotifyId != nil {
		object["spotify_id"], err = json.Marshal(a.SpotifyId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'spotify_id': %w", err)
		}
	}

	if a.SubmissionClient != nil {
		object["submission_client"], err = json.Marshal(a.SubmissionClient)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'submission_client': %w", err)
		}
	}

	if a.SubmissionClientVersion != nil {
		object["submission_client_version"], err = json.Marshal(a.SubmissionClientVersion)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'submission_client_version': %w", err)
		}
	}

	if a.Tags != nil {
		object["tags"], err = json.Marshal(a.Tags)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'tags': %w", err)
		}
	}

	if a.TrackNumber != nil {
		object["trackNumber"], err = json.Marshal(a.TrackNumber)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'trackNumber': %w", err)
		}
	}

	if a.TrackMbid != nil {
		object["track_mbid"], err = json.Marshal(a.TrackMbid)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'track_mbid': %w", err)
		}
	}

	if a.Tracknumber != nil {
		object["tracknumber"], err = json.Marshal(a.Tracknumber)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'tracknumber': %w", err)
		}
	}

	if a.WorkMbids != nil {
		object["work_mbids"], err = json.Marshal(a.WorkMbids)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'work_mbids': %w", err)
		}
	}

	if a.YoutubeId != nil {
		object["youtube_id"], err = json.Marshal(a.YoutubeId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'youtube_id': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Metadata. Returns the specified
// element and whether it was found
func (a Metadata) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Metadata
func (a *Metadata) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Metadata to handle AdditionalProperties
func (a *Metadata) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["blurb_content"]; found {
		err = json.Unmarshal(raw, &a.BlurbContent)
		if err != nil {
			return fmt.Errorf("error reading 'blurb_content': %w", err)
		}
		delete(object, "blurb_content")
	}

	if raw, found := object["created"]; found {
		err = json.Unmarshal(raw, &a.Created)
		if err != nil {
			return fmt.Errorf("error reading 'created': %w", err)
		}
		delete(object, "created")
	}

	if raw, found := object["inserted_at"]; found {
		err = json.Unmarshal(raw, &a.InsertedAt)
		if err != nil {
			return fmt.Errorf("error reading 'inserted_at': %w", err)
		}
		delete(object, "inserted_at")
	}

	if raw, found := object["listened_at"]; found {
		err = json.Unmarshal(raw, &a.ListenedAt)
		if err != nil {
			return fmt.Errorf("error reading 'listened_at': %w", err)
		}
		delete(object, "listened_at")
	}

	if raw, found := object["listened_at_iso"]; found {
		err = json.Unmarshal(raw, &a.ListenedAtIso)
		if err != nil {
			return fmt.Errorf("error reading 'listened_at_iso': %w", err)
		}
		delete(object, "listened_at_iso")
	}

	if raw, found := object["message"]; found {
		err = json.Unmarshal(raw, &a.Message)
		if err != nil {
			return fmt.Errorf("error reading 'message': %w", err)
		}
		delete(object, "message")
	}

	if raw, found := object["playing_now"]; found {
		err = json.Unmarshal(raw, &a.PlayingNow)
		if err != nil {
			return fmt.Errorf("error reading 'playing_now': %w", err)
		}
		delete(object, "playing_now")
	}

	if raw, found := object["relationship_type"]; found {
		err = json.Unmarshal(raw, &a.RelationshipType)
		if err != nil {
			return fmt.Errorf("error reading 'relationship_type': %w", err)
		}
		delete(object, "relationship_type")
	}

	if raw, found := object["track_metadata"]; found {
		err = json.Unmarshal(raw, &a.TrackMetadata)
		if err != nil {
			return fmt.Errorf("error reading 'track_metadata': %w", err)
		}
		delete(object, "track_metadata")
	}

	if raw, found := object["user_name"]; found {
		err = json.Unmarshal(raw, &a.UserName)
		if err != nil {
			return fmt.Errorf("error reading 'user_name': %w", err)
		}
		delete(object, "user_name")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Metadata to handle AdditionalProperties
func (a Metadata) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.BlurbContent != nil {
		object["blurb_content"], err = json.Marshal(a.BlurbContent)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'blurb_content': %w", err)
		}
	}

	if a.Created != nil {
		object["created"], err = json.Marshal(a.Created)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'created': %w", err)
		}
	}

	if a.InsertedAt != nil {
		object["inserted_at"], err = json.Marshal(a.InsertedAt)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'inserted_at': %w", err)
		}
	}

	if a.ListenedAt != nil {
		object["listened_at"], err = json.Marshal(a.ListenedAt)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'listened_at': %w", err)
		}
	}

	if a.ListenedAtIso != nil {
		object["listened_at_iso"], err = json.Marshal(a.ListenedAtIso)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'listened_at_iso': %w", err)
		}
	}

	if a.Message != nil {
		object["message"], err = json.Marshal(a.Message)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'message': %w", err)
		}
	}

	if a.PlayingNow != nil {
		object["playing_now"], err = json.Marshal(a.PlayingNow)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'playing_now': %w", err)
		}
	}

	if a.RelationshipType != nil {
		object["relationship_type"], err = json.Marshal(a.RelationshipType)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'relationship_type': %w", err)
		}
	}

	if a.TrackMetadata != nil {
		object["track_metadata"], err = json.Marshal(a.TrackMetadata)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'track_metadata': %w", err)
		}
	}

	if a.UserName != nil {
		object["user_name"], err = json.Marshal(a.UserName)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'user_name': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PlaylistExtensionPayloadAdditionalMetadata. Returns the specified
// element and whether it was found
func (a PlaylistExtensionPayloadAdditionalMetadata) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PlaylistExtensionPayloadAdditionalMetadata
func (a *PlaylistExtensionPayloadAdditionalMetadata) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PlaylistExtensionPayloadAdditionalMetadata to handle AdditionalProperties
func (a *PlaylistExtensionPayloadAdditionalMetadata) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["algorithm_metadata"]; found {
		err = json.Unmarshal(raw, &a.AlgorithmMetadata)
		if err != nil {
			return fmt.Errorf("error reading 'algorithm_metadata': %w", err)
		}
		delete(object, "algorithm_metadata")
	}

	if raw, found := object["cover_art"]; found {
		err = json.Unmarshal(raw, &a.CoverArt)
		if err != nil {
			return fmt.Errorf("error reading 'cover_art': %w", err)
		}
		delete(object, "cover_art")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PlaylistExtensionPayloadAdditionalMetadata to handle AdditionalProperties
func (a PlaylistExtensionPayloadAdditionalMetadata) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.AlgorithmMetadata != nil {
		object["algorithm_metadata"], err = json.Marshal(a.AlgorithmMetadata)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'algorithm_metadata': %w", err)
		}
	}

	if a.CoverArt != nil {
		object["cover_art"], err = json.Marshal(a.CoverArt)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'cover_art': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// CreateCoverArtGridForUser request
	CreateCoverArtGridForUser(ctx context.Context, userName string, timeRange AllowedStatisticsRange, dimension int, layout int, imageSize int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCoverArtGridWithBody request with any body
	CreateCoverArtGridWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateCoverArtGrid(ctx context.Context, body CreateCoverArtGridJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// YearInMusic request
	YearInMusic(ctx context.Context, year int, userName string, params *YearInMusicParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCustomCoverArt request
	CreateCustomCoverArt(ctx context.Context, customName CoverTypes, userName string, timeRange AllowedStatisticsRange, imageSize int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RecordingRecommendations request
	RecordingRecommendations(ctx context.Context, userName string, params *RecordingRecommendationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteListenWithBody request with any body
	DeleteListenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteListen(ctx context.Context, body DeleteListenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Color request
	Color(ctx context.Context, color string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FreshReleases request
	FreshReleases(ctx context.Context, params *FreshReleasesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LbRadio request
	LbRadio(ctx context.Context, params *LbRadioParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RecordingFeedbackWithBody request with any body
	RecordingFeedbackWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RecordingFeedback(ctx context.Context, body RecordingFeedbackJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFeedbackMbid request
	GetFeedbackMbid(ctx context.Context, recordingMbid openapi_types.UUID, params *GetFeedbackMbidParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFeedbackMsid request
	GetFeedbackMsid(ctx context.Context, recordingMsid string, params *GetFeedbackMsidParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFeedback request
	GetFeedback(ctx context.Context, userName string, params *GetFeedbackParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFeedbackForRecordings request
	GetFeedbackForRecordings(ctx context.Context, userName string, params *GetFeedbackForRecordingsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LatestImport request
	LatestImport(ctx context.Context, params *LatestImportParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LbRadioRecordingsForArtist request
	LbRadioRecordingsForArtist(ctx context.Context, seedArtistMbid openapi_types.UUID, params *LbRadioRecordingsForArtistParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LbRadioTags request
	LbRadioTags(ctx context.Context, params *LbRadioTagsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArtistMetadata request
	ArtistMetadata(ctx context.Context, params *ArtistMetadataParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetManualMapping request
	GetManualMapping(ctx context.Context, params *GetManualMappingParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Lookup request
	Lookup(ctx context.Context, params *LookupParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RecordingMetadata request
	RecordingMetadata(ctx context.Context, params *RecordingMetadataParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReleaseGroupMetadata request
	ReleaseGroupMetadata(ctx context.Context, params *ReleaseGroupMetadataParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SubmitManualMappingWithBody request with any body
	SubmitManualMappingWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SubmitManualMapping(ctx context.Context, body SubmitManualMappingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PinWithBody request with any body
	PinWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Pin(ctx context.Context, body PinJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PinDelete request
	PinDelete(ctx context.Context, rowId int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePinWithBody request with any body
	UpdatePinWithBody(ctx context.Context, rowId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePin(ctx context.Context, rowId int, body UpdatePinJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePlaylistWithBody request with any body
	CreatePlaylistWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePlaylist(ctx context.Context, body CreatePlaylistJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EditPlaylistWithBody request with any body
	EditPlaylistWithBody(ctx context.Context, playlistMbid openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EditPlaylist(ctx context.Context, playlistMbid openapi_types.UUID, body EditPlaylistJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchPlaylists request
	SearchPlaylists(ctx context.Context, params *SearchPlaylistsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FetchPlaylist request
	FetchPlaylist(ctx context.Context, playlistMbid openapi_types.UUID, params *FetchPlaylistParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CopyPlaylist request
	CopyPlaylist(ctx context.Context, playlistMbid openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePlaylist request
	DeletePlaylist(ctx context.Context, playlistMbid openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppendRecordingsWithBody request with any body
	AppendRecordingsWithBody(ctx context.Context, playlistMbid openapi_types.UUID, offset int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AppendRecordings(ctx context.Context, playlistMbid openapi_types.UUID, offset int, body AppendRecordingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ItemDeleteWithBody request with any body
	ItemDeleteWithBody(ctx context.Context, playlistMbid openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ItemDelete(ctx context.Context, playlistMbid openapi_types.UUID, body ItemDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MoveItemWithBody request with any body
	MoveItemWithBody(ctx context.Context, playlistMbid openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MoveItem(ctx context.Context, playlistMbid openapi_types.UUID, body MoveItemJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArtistWithBody request with any body
	ArtistWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Artist(ctx context.Context, body ArtistJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RecordingWithBody request with any body
	RecordingWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Recording(ctx context.Context, body RecordingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReleaseWithBody request with any body
	ReleaseWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Release(ctx context.Context, body ReleaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReleaseGroupWithBody request with any body
	ReleaseGroupWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReleaseGroup(ctx context.Context, body ReleaseGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TopRecordingsForArtist request
	TopRecordingsForArtist(ctx context.Context, artistMbid openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TopReleaseGroupForArtist request
	TopReleaseGroupForArtist(ctx context.Context, artistMbid openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SubmitFeedbackWithBody request with any body
	SubmitFeedbackWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SubmitFeedback(ctx context.Context, body SubmitFeedbackJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteFeedbackWithBody request with any body
	DeleteFeedbackWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteFeedback(ctx context.Context, body DeleteFeedbackJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FeedbackGivenBy request
	FeedbackGivenBy(ctx context.Context, userName string, params *FeedbackGivenByParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RecordingsFeedbackGivenBy request
	RecordingsFeedbackGivenBy(ctx context.Context, userName string, params *RecordingsFeedbackGivenByParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchUsers request
	SearchUsers(ctx context.Context, params *SearchUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListenersForArtist request
	ListenersForArtist(ctx context.Context, artistMbid openapi_types.UUID, params *ListenersForArtistParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListenersForReleaseGroup request
	ListenersForReleaseGroup(ctx context.Context, releaseGroupMbid openapi_types.UUID, params *ListenersForReleaseGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SitewideArtistMap request
	SitewideArtistMap(ctx context.Context, params *SitewideArtistMapParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SitewideTopArtists request
	SitewideTopArtists(ctx context.Context, params *SitewideTopArtistsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SitewideListeningActivity request
	SitewideListeningActivity(ctx context.Context, params *SitewideListeningActivityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SitewideTopRecordings request
	SitewideTopRecordings(ctx context.Context, params *SitewideTopRecordingsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SitewideTopReleaseGroups request
	SitewideTopReleaseGroups(ctx context.Context, params *SitewideTopReleaseGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SitewideTopReleases request
	SitewideTopReleases(ctx context.Context, params *SitewideTopReleasesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArtistMapForUser request
	ArtistMapForUser(ctx context.Context, userName string, params *ArtistMapForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TopArtistsForUser request
	TopArtistsForUser(ctx context.Context, userName string, params *TopArtistsForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DailyActivityForUser request
	DailyActivityForUser(ctx context.Context, userName string, params *DailyActivityForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListeningActivityForUser request
	ListeningActivityForUser(ctx context.Context, userName string, params *ListeningActivityForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TopRecordingsForUser request
	TopRecordingsForUser(ctx context.Context, userName string, params *TopRecordingsForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TopReleaseGroupsForUser request
	TopReleaseGroupsForUser(ctx context.Context, userName string, params *TopReleaseGroupsForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TopReleasesForUser request
	TopReleasesForUser(ctx context.Context, userName string, params *TopReleasesForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// YearInMusicForUser request
	YearInMusicForUser(ctx context.Context, userName string, year int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDumpInfo request
	GetDumpInfo(ctx context.Context, params *GetDumpInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SubmitListensWithBody request with any body
	SubmitListensWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SubmitListens(ctx context.Context, body SubmitListensJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Unpin request
	Unpin(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PlaylistsForUser request
	PlaylistsForUser(ctx context.Context, playlistUserName string, params *PlaylistsForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PlaylistsForUserCollaborator request
	PlaylistsForUserCollaborator(ctx context.Context, playlistUserName string, params *PlaylistsForUserCollaboratorParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PlaylistsCreatedForUser request
	PlaylistsCreatedForUser(ctx context.Context, playlistUserName string, params *PlaylistsCreatedForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RecommendationPlaylistsForUser request
	RecommendationPlaylistsForUser(ctx context.Context, playlistUserName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchPlaylistForUser request
	SearchPlaylistForUser(ctx context.Context, playlistUserName string, params *SearchPlaylistForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FeedEvents request
	FeedEvents(ctx context.Context, userName string, params *FeedEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FeedEventsDeleteWithBody request with any body
	FeedEventsDeleteWithBody(ctx context.Context, userName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FeedEventsDelete(ctx context.Context, userName string, body FeedEventsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FeedEventsHideWithBody request with any body
	FeedEventsHideWithBody(ctx context.Context, userName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FeedEventsHide(ctx context.Context, userName string, body FeedEventsHideJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FeedEventsListensFollowing request
	FeedEventsListensFollowing(ctx context.Context, userName string, params *FeedEventsListensFollowingParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FeedEventsListensSimilar request
	FeedEventsListensSimilar(ctx context.Context, userName string, params *FeedEventsListensSimilarParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FeedEventsUnhideWithBody request with any body
	FeedEventsUnhideWithBody(ctx context.Context, userName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FeedEventsUnhide(ctx context.Context, userName string, body FeedEventsUnhideJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Follow request
	Follow(ctx context.Context, userName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Followers request
	Followers(ctx context.Context, userName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Following request
	Following(ctx context.Context, userName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListenCountForUser request
	ListenCountForUser(ctx context.Context, userName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListensForUser request
	ListensForUser(ctx context.Context, userName string, params *ListensForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PlayingNowForUser request
	PlayingNowForUser(ctx context.Context, userName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ServicesForUser request
	ServicesForUser(ctx context.Context, userName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SimilarityOfUserForUser request
	SimilarityOfUserForUser(ctx context.Context, userName string, otherUserName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SimilarUsersForUser request
	SimilarUsersForUser(ctx context.Context, userName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateNotificationWithBody request with any body
	CreateNotificationWithBody(ctx context.Context, userName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateNotification(ctx context.Context, userName string, body CreateNotificationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RecommendPersonalRecordingWithBody request with any body
	RecommendPersonalRecordingWithBody(ctx context.Context, userName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RecommendPersonalRecording(ctx context.Context, userName string, body RecommendPersonalRecordingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RecommendRecordingWithBody request with any body
	RecommendRecordingWithBody(ctx context.Context, userName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RecommendRecording(ctx context.Context, userName string, body RecommendRecordingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateReviewWithBody request with any body
	CreateReviewWithBody(ctx context.Context, userName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateReview(ctx context.Context, userName string, body CreateReviewJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Unfollow request
	Unfollow(ctx context.Context, userName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ValidateToken request
	ValidateToken(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPins request
	GetPins(ctx context.Context, userName string, params *GetPinsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPinsCurrent request
	GetPinsCurrent(ctx context.Context, userName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPinsFollowing request
	GetPinsFollowing(ctx context.Context, userName string, params *GetPinsFollowingParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) CreateCoverArtGridForUser(ctx context.Context, userName string, timeRange AllowedStatisticsRange, dimension int, layout int, imageSize int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCoverArtGridForUserRequest(c.Server, userName, timeRange, dimension, layout, imageSize)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCoverArtGridWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCoverArtGridRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCoverArtGrid(ctx context.Context, body CreateCoverArtGridJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCoverArtGridRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) YearInMusic(ctx context.Context, year int, userName string, params *YearInMusicParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewYearInMusicRequest(c.Server, year, userName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCustomCoverArt(ctx context.Context, customName CoverTypes, userName string, timeRange AllowedStatisticsRange, imageSize int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCustomCoverArtRequest(c.Server, customName, userName, timeRange, imageSize)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RecordingRecommendations(ctx context.Context, userName string, params *RecordingRecommendationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRecordingRecommendationsRequest(c.Server, userName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteListenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteListenRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteListen(ctx context.Context, body DeleteListenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteListenRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Color(ctx context.Context, color string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewColorRequest(c.Server, color)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FreshReleases(ctx context.Context, params *FreshReleasesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFreshReleasesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LbRadio(ctx context.Context, params *LbRadioParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLbRadioRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RecordingFeedbackWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRecordingFeedbackRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RecordingFeedback(ctx context.Context, body RecordingFeedbackJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRecordingFeedbackRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFeedbackMbid(ctx context.Context, recordingMbid openapi_types.UUID, params *GetFeedbackMbidParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFeedbackMbidRequest(c.Server, recordingMbid, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFeedbackMsid(ctx context.Context, recordingMsid string, params *GetFeedbackMsidParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFeedbackMsidRequest(c.Server, recordingMsid, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFeedback(ctx context.Context, userName string, params *GetFeedbackParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFeedbackRequest(c.Server, userName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFeedbackForRecordings(ctx context.Context, userName string, params *GetFeedbackForRecordingsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFeedbackForRecordingsRequest(c.Server, userName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LatestImport(ctx context.Context, params *LatestImportParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLatestImportRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LbRadioRecordingsForArtist(ctx context.Context, seedArtistMbid openapi_types.UUID, params *LbRadioRecordingsForArtistParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLbRadioRecordingsForArtistRequest(c.Server, seedArtistMbid, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LbRadioTags(ctx context.Context, params *LbRadioTagsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLbRadioTagsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArtistMetadata(ctx context.Context, params *ArtistMetadataParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArtistMetadataRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetManualMapping(ctx context.Context, params *GetManualMappingParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetManualMappingRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Lookup(ctx context.Context, params *LookupParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLookupRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RecordingMetadata(ctx context.Context, params *RecordingMetadataParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRecordingMetadataRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReleaseGroupMetadata(ctx context.Context, params *ReleaseGroupMetadataParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReleaseGroupMetadataRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SubmitManualMappingWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSubmitManualMappingRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SubmitManualMapping(ctx context.Context, body SubmitManualMappingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSubmitManualMappingRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PinWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPinRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Pin(ctx context.Context, body PinJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPinRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PinDelete(ctx context.Context, rowId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPinDeleteRequest(c.Server, rowId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePinWithBody(ctx context.Context, rowId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePinRequestWithBody(c.Server, rowId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePin(ctx context.Context, rowId int, body UpdatePinJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePinRequest(c.Server, rowId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePlaylistWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePlaylistRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePlaylist(ctx context.Context, body CreatePlaylistJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePlaylistRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditPlaylistWithBody(ctx context.Context, playlistMbid openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditPlaylistRequestWithBody(c.Server, playlistMbid, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditPlaylist(ctx context.Context, playlistMbid openapi_types.UUID, body EditPlaylistJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditPlaylistRequest(c.Server, playlistMbid, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchPlaylists(ctx context.Context, params *SearchPlaylistsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchPlaylistsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FetchPlaylist(ctx context.Context, playlistMbid openapi_types.UUID, params *FetchPlaylistParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFetchPlaylistRequest(c.Server, playlistMbid, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CopyPlaylist(ctx context.Context, playlistMbid openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCopyPlaylistRequest(c.Server, playlistMbid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePlaylist(ctx context.Context, playlistMbid openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePlaylistRequest(c.Server, playlistMbid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppendRecordingsWithBody(ctx context.Context, playlistMbid openapi_types.UUID, offset int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppendRecordingsRequestWithBody(c.Server, playlistMbid, offset, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppendRecordings(ctx context.Context, playlistMbid openapi_types.UUID, offset int, body AppendRecordingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppendRecordingsRequest(c.Server, playlistMbid, offset, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ItemDeleteWithBody(ctx context.Context, playlistMbid openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewItemDeleteRequestWithBody(c.Server, playlistMbid, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ItemDelete(ctx context.Context, playlistMbid openapi_types.UUID, body ItemDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewItemDeleteRequest(c.Server, playlistMbid, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MoveItemWithBody(ctx context.Context, playlistMbid openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMoveItemRequestWithBody(c.Server, playlistMbid, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MoveItem(ctx context.Context, playlistMbid openapi_types.UUID, body MoveItemJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMoveItemRequest(c.Server, playlistMbid, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArtistWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArtistRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Artist(ctx context.Context, body ArtistJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArtistRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RecordingWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRecordingRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Recording(ctx context.Context, body RecordingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRecordingRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReleaseWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReleaseRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Release(ctx context.Context, body ReleaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReleaseRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReleaseGroupWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReleaseGroupRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReleaseGroup(ctx context.Context, body ReleaseGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReleaseGroupRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TopRecordingsForArtist(ctx context.Context, artistMbid openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTopRecordingsForArtistRequest(c.Server, artistMbid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TopReleaseGroupForArtist(ctx context.Context, artistMbid openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTopReleaseGroupForArtistRequest(c.Server, artistMbid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SubmitFeedbackWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSubmitFeedbackRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SubmitFeedback(ctx context.Context, body SubmitFeedbackJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSubmitFeedbackRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFeedbackWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFeedbackRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFeedback(ctx context.Context, body DeleteFeedbackJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFeedbackRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FeedbackGivenBy(ctx context.Context, userName string, params *FeedbackGivenByParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFeedbackGivenByRequest(c.Server, userName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RecordingsFeedbackGivenBy(ctx context.Context, userName string, params *RecordingsFeedbackGivenByParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRecordingsFeedbackGivenByRequest(c.Server, userName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchUsers(ctx context.Context, params *SearchUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchUsersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListenersForArtist(ctx context.Context, artistMbid openapi_types.UUID, params *ListenersForArtistParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListenersForArtistRequest(c.Server, artistMbid, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListenersForReleaseGroup(ctx context.Context, releaseGroupMbid openapi_types.UUID, params *ListenersForReleaseGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListenersForReleaseGroupRequest(c.Server, releaseGroupMbid, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SitewideArtistMap(ctx context.Context, params *SitewideArtistMapParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSitewideArtistMapRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SitewideTopArtists(ctx context.Context, params *SitewideTopArtistsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSitewideTopArtistsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SitewideListeningActivity(ctx context.Context, params *SitewideListeningActivityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSitewideListeningActivityRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SitewideTopRecordings(ctx context.Context, params *SitewideTopRecordingsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSitewideTopRecordingsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SitewideTopReleaseGroups(ctx context.Context, params *SitewideTopReleaseGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSitewideTopReleaseGroupsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SitewideTopReleases(ctx context.Context, params *SitewideTopReleasesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSitewideTopReleasesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArtistMapForUser(ctx context.Context, userName string, params *ArtistMapForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArtistMapForUserRequest(c.Server, userName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TopArtistsForUser(ctx context.Context, userName string, params *TopArtistsForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTopArtistsForUserRequest(c.Server, userName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DailyActivityForUser(ctx context.Context, userName string, params *DailyActivityForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDailyActivityForUserRequest(c.Server, userName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListeningActivityForUser(ctx context.Context, userName string, params *ListeningActivityForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListeningActivityForUserRequest(c.Server, userName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TopRecordingsForUser(ctx context.Context, userName string, params *TopRecordingsForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTopRecordingsForUserRequest(c.Server, userName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TopReleaseGroupsForUser(ctx context.Context, userName string, params *TopReleaseGroupsForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTopReleaseGroupsForUserRequest(c.Server, userName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TopReleasesForUser(ctx context.Context, userName string, params *TopReleasesForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTopReleasesForUserRequest(c.Server, userName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) YearInMusicForUser(ctx context.Context, userName string, year int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewYearInMusicForUserRequest(c.Server, userName, year)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDumpInfo(ctx context.Context, params *GetDumpInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDumpInfoRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SubmitListensWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSubmitListensRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SubmitListens(ctx context.Context, body SubmitListensJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSubmitListensRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Unpin(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnpinRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PlaylistsForUser(ctx context.Context, playlistUserName string, params *PlaylistsForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPlaylistsForUserRequest(c.Server, playlistUserName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PlaylistsForUserCollaborator(ctx context.Context, playlistUserName string, params *PlaylistsForUserCollaboratorParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPlaylistsForUserCollaboratorRequest(c.Server, playlistUserName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PlaylistsCreatedForUser(ctx context.Context, playlistUserName string, params *PlaylistsCreatedForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPlaylistsCreatedForUserRequest(c.Server, playlistUserName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RecommendationPlaylistsForUser(ctx context.Context, playlistUserName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRecommendationPlaylistsForUserRequest(c.Server, playlistUserName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchPlaylistForUser(ctx context.Context, playlistUserName string, params *SearchPlaylistForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchPlaylistForUserRequest(c.Server, playlistUserName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FeedEvents(ctx context.Context, userName string, params *FeedEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFeedEventsRequest(c.Server, userName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FeedEventsDeleteWithBody(ctx context.Context, userName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFeedEventsDeleteRequestWithBody(c.Server, userName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FeedEventsDelete(ctx context.Context, userName string, body FeedEventsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFeedEventsDeleteRequest(c.Server, userName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FeedEventsHideWithBody(ctx context.Context, userName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFeedEventsHideRequestWithBody(c.Server, userName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FeedEventsHide(ctx context.Context, userName string, body FeedEventsHideJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFeedEventsHideRequest(c.Server, userName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FeedEventsListensFollowing(ctx context.Context, userName string, params *FeedEventsListensFollowingParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFeedEventsListensFollowingRequest(c.Server, userName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FeedEventsListensSimilar(ctx context.Context, userName string, params *FeedEventsListensSimilarParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFeedEventsListensSimilarRequest(c.Server, userName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FeedEventsUnhideWithBody(ctx context.Context, userName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFeedEventsUnhideRequestWithBody(c.Server, userName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FeedEventsUnhide(ctx context.Context, userName string, body FeedEventsUnhideJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFeedEventsUnhideRequest(c.Server, userName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Follow(ctx context.Context, userName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFollowRequest(c.Server, userName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Followers(ctx context.Context, userName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFollowersRequest(c.Server, userName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Following(ctx context.Context, userName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFollowingRequest(c.Server, userName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListenCountForUser(ctx context.Context, userName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListenCountForUserRequest(c.Server, userName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListensForUser(ctx context.Context, userName string, params *ListensForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListensForUserRequest(c.Server, userName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PlayingNowForUser(ctx context.Context, userName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPlayingNowForUserRequest(c.Server, userName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ServicesForUser(ctx context.Context, userName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewServicesForUserRequest(c.Server, userName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SimilarityOfUserForUser(ctx context.Context, userName string, otherUserName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSimilarityOfUserForUserRequest(c.Server, userName, otherUserName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SimilarUsersForUser(ctx context.Context, userName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSimilarUsersForUserRequest(c.Server, userName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNotificationWithBody(ctx context.Context, userName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNotificationRequestWithBody(c.Server, userName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNotification(ctx context.Context, userName string, body CreateNotificationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNotificationRequest(c.Server, userName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RecommendPersonalRecordingWithBody(ctx context.Context, userName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRecommendPersonalRecordingRequestWithBody(c.Server, userName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RecommendPersonalRecording(ctx context.Context, userName string, body RecommendPersonalRecordingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRecommendPersonalRecordingRequest(c.Server, userName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RecommendRecordingWithBody(ctx context.Context, userName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRecommendRecordingRequestWithBody(c.Server, userName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RecommendRecording(ctx context.Context, userName string, body RecommendRecordingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRecommendRecordingRequest(c.Server, userName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateReviewWithBody(ctx context.Context, userName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateReviewRequestWithBody(c.Server, userName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateReview(ctx context.Context, userName string, body CreateReviewJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateReviewRequest(c.Server, userName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Unfollow(ctx context.Context, userName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnfollowRequest(c.Server, userName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidateToken(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidateTokenRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPins(ctx context.Context, userName string, params *GetPinsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPinsRequest(c.Server, userName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPinsCurrent(ctx context.Context, userName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPinsCurrentRequest(c.Server, userName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPinsFollowing(ctx context.Context, userName string, params *GetPinsFollowingParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPinsFollowingRequest(c.Server, userName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewCreateCoverArtGridForUserRequest generates requests for CreateCoverArtGridForUser
func NewCreateCoverArtGridForUserRequest(server string, userName string, timeRange AllowedStatisticsRange, dimension int, layout int, imageSize int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_name", runtime.ParamLocationPath, userName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "time_range", runtime.ParamLocationPath, timeRange)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "dimension", runtime.ParamLocationPath, dimension)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "layout", runtime.ParamLocationPath, layout)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "image_size", runtime.ParamLocationPath, imageSize)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/art/grid-stats/%s/%s/%s/%s/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateCoverArtGridRequest calls the generic CreateCoverArtGrid builder with application/json body
func NewCreateCoverArtGridRequest(server string, body CreateCoverArtGridJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateCoverArtGridRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateCoverArtGridRequestWithBody generates requests for CreateCoverArtGrid with any type of body
func NewCreateCoverArtGridRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/art/grid/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewYearInMusicRequest generates requests for YearInMusic
func NewYearInMusicRequest(server string, year int, userName string, params *YearInMusicParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "year", runtime.ParamLocationPath, year)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "user_name", runtime.ParamLocationPath, userName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/art/year-in-music/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "image", runtime.ParamLocationQuery, params.Image); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateCustomCoverArtRequest generates requests for CreateCustomCoverArt
func NewCreateCustomCoverArtRequest(server string, customName CoverTypes, userName string, timeRange AllowedStatisticsRange, imageSize int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "custom_name", runtime.ParamLocationPath, customName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "user_name", runtime.ParamLocationPath, userName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "time_range", runtime.ParamLocationPath, timeRange)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "image_size", runtime.ParamLocationPath, imageSize)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/art/%s/%s/%s/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRecordingRecommendationsRequest generates requests for RecordingRecommendations
func NewRecordingRecommendationsRequest(server string, userName string, params *RecordingRecommendationsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_name", runtime.ParamLocationPath, userName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/cf/recommendation/user/%s/recording", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Count != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteListenRequest calls the generic DeleteListen builder with application/json body
func NewDeleteListenRequest(server string, body DeleteListenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteListenRequestWithBody(server, "application/json", bodyReader)
}

// NewDeleteListenRequestWithBody generates requests for DeleteListen with any type of body
func NewDeleteListenRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/delete-listen")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewColorRequest generates requests for Color
func NewColorRequest(server string, color string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "color", runtime.ParamLocationPath, color)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/explore/color/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFreshReleasesRequest generates requests for FreshReleases
func NewFreshReleasesRequest(server string, params *FreshReleasesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/explore/fresh-releases/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ReleaseDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "release_date", runtime.ParamLocationQuery, *params.ReleaseDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Days != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "days", runtime.ParamLocationQuery, *params.Days); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Past != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "past", runtime.ParamLocationQuery, *params.Past); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Future != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "future", runtime.ParamLocationQuery, *params.Future); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLbRadioRequest generates requests for LbRadio
func NewLbRadioRequest(server string, params *LbRadioParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/explore/lb-radio")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prompt", runtime.ParamLocationQuery, params.Prompt); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mode", runtime.ParamLocationQuery, params.Mode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRecordingFeedbackRequest calls the generic RecordingFeedback builder with application/json body
func NewRecordingFeedbackRequest(server string, body RecordingFeedbackJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRecordingFeedbackRequestWithBody(server, "application/json", bodyReader)
}

// NewRecordingFeedbackRequestWithBody generates requests for RecordingFeedback with any type of body
func NewRecordingFeedbackRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/feedback/recording-feedback")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetFeedbackMbidRequest generates requests for GetFeedbackMbid
func NewGetFeedbackMbidRequest(server string, recordingMbid openapi_types.UUID, params *GetFeedbackMbidParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "recording_mbid", runtime.ParamLocationPath, recordingMbid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/feedback/recording/%s/get-feedback-mbid", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Score != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "score", runtime.ParamLocationQuery, *params.Score); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Count != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFeedbackMsidRequest generates requests for GetFeedbackMsid
func NewGetFeedbackMsidRequest(server string, recordingMsid string, params *GetFeedbackMsidParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "recording_msid", runtime.ParamLocationPath, recordingMsid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/feedback/user/%s/get-feedback", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Score != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "score", runtime.ParamLocationQuery, *params.Score); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Count != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFeedbackRequest generates requests for GetFeedback
func NewGetFeedbackRequest(server string, userName string, params *GetFeedbackParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_name", runtime.ParamLocationPath, userName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/feedback/user/%s/get-feedback", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Score != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "score", runtime.ParamLocationQuery, *params.Score); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Count != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Metadata != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "metadata", runtime.ParamLocationQuery, *params.Metadata); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFeedbackForRecordingsRequest generates requests for GetFeedbackForRecordings
func NewGetFeedbackForRecordingsRequest(server string, userName string, params *GetFeedbackForRecordingsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_name", runtime.ParamLocationPath, userName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/feedback/user/%s/get-feedback-for-recordings", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.RecordingMsids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "recording_msids", runtime.ParamLocationQuery, *params.RecordingMsids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RecordingMbids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "recording_mbids", runtime.ParamLocationQuery, *params.RecordingMbids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLatestImportRequest generates requests for LatestImport
func NewLatestImportRequest(server string, params *LatestImportParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/latest-import")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_name", runtime.ParamLocationQuery, params.UserName); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLbRadioRecordingsForArtistRequest generates requests for LbRadioRecordingsForArtist
func NewLbRadioRecordingsForArtistRequest(server string, seedArtistMbid openapi_types.UUID, params *LbRadioRecordingsForArtistParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "seed_artist_mbid", runtime.ParamLocationPath, seedArtistMbid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/lb-radio/artist/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mode", runtime.ParamLocationQuery, params.Mode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_similar_artists", runtime.ParamLocationQuery, params.MaxSimilarArtists); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_recordings_per_artist", runtime.ParamLocationQuery, params.MaxRecordingsPerArtist); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pop_begin", runtime.ParamLocationQuery, params.PopBegin); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pop_end", runtime.ParamLocationQuery, params.PopEnd); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLbRadioTagsRequest generates requests for LbRadioTags
func NewLbRadioTagsRequest(server string, params *LbRadioTagsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/lb-radio/tags")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag", runtime.ParamLocationQuery, params.Tag); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Operator != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "operator", runtime.ParamLocationQuery, *params.Operator); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pop_begin", runtime.ParamLocationQuery, params.PopBegin); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pop_end", runtime.ParamLocationQuery, params.PopEnd); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewArtistMetadataRequest generates requests for ArtistMetadata
func NewArtistMetadataRequest(server string, params *ArtistMetadataParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/metadata/artist/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "artist_mbids", runtime.ParamLocationQuery, params.ArtistMbids); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "inc", runtime.ParamLocationQuery, params.Inc); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetManualMappingRequest generates requests for GetManualMapping
func NewGetManualMappingRequest(server string, params *GetManualMappingParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/metadata/get_manual_mapping/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "recording_msid", runtime.ParamLocationQuery, params.RecordingMsid); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLookupRequest generates requests for Lookup
func NewLookupRequest(server string, params *LookupParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/metadata/lookup/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "artist_name", runtime.ParamLocationQuery, params.ArtistName); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "recording_name", runtime.ParamLocationQuery, params.RecordingName); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.ReleaseName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "release_name", runtime.ParamLocationQuery, *params.ReleaseName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "metadata", runtime.ParamLocationQuery, params.Metadata); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "inc", runtime.ParamLocationQuery, params.Inc); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRecordingMetadataRequest generates requests for RecordingMetadata
func NewRecordingMetadataRequest(server string, params *RecordingMetadataParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/metadata/recording/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "recording_mbids", runtime.ParamLocationQuery, params.RecordingMbids); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "inc", runtime.ParamLocationQuery, params.Inc); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReleaseGroupMetadataRequest generates requests for ReleaseGroupMetadata
func NewReleaseGroupMetadataRequest(server string, params *ReleaseGroupMetadataParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/metadata/release_group/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "release_group_mbids", runtime.ParamLocationQuery, params.ReleaseGroupMbids); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "inc", runtime.ParamLocationQuery, params.Inc); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSubmitManualMappingRequest calls the generic SubmitManualMapping builder with application/json body
func NewSubmitManualMappingRequest(server string, body SubmitManualMappingJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSubmitManualMappingRequestWithBody(server, "application/json", bodyReader)
}

// NewSubmitManualMappingRequestWithBody generates requests for SubmitManualMapping with any type of body
func NewSubmitManualMappingRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/metadata/submit_manual_mapping/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPinRequest calls the generic Pin builder with application/json body
func NewPinRequest(server string, body PinJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPinRequestWithBody(server, "application/json", bodyReader)
}

// NewPinRequestWithBody generates requests for Pin with any type of body
func NewPinRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/pin")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPinDeleteRequest generates requests for PinDelete
func NewPinDeleteRequest(server string, rowId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "row_id", runtime.ParamLocationPath, rowId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/pin/delete/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePinRequest calls the generic UpdatePin builder with application/json body
func NewUpdatePinRequest(server string, rowId int, body UpdatePinJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePinRequestWithBody(server, rowId, "application/json", bodyReader)
}

// NewUpdatePinRequestWithBody generates requests for UpdatePin with any type of body
func NewUpdatePinRequestWithBody(server string, rowId int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "row_id", runtime.ParamLocationPath, rowId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/pin/update/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreatePlaylistRequest calls the generic CreatePlaylist builder with application/json body
func NewCreatePlaylistRequest(server string, body CreatePlaylistJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePlaylistRequestWithBody(server, "application/json", bodyReader)
}

// NewCreatePlaylistRequestWithBody generates requests for CreatePlaylist with any type of body
func NewCreatePlaylistRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/playlist/create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEditPlaylistRequest calls the generic EditPlaylist builder with application/json body
func NewEditPlaylistRequest(server string, playlistMbid openapi_types.UUID, body EditPlaylistJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEditPlaylistRequestWithBody(server, playlistMbid, "application/json", bodyReader)
}

// NewEditPlaylistRequestWithBody generates requests for EditPlaylist with any type of body
func NewEditPlaylistRequestWithBody(server string, playlistMbid openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "playlist_mbid", runtime.ParamLocationPath, playlistMbid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/playlist/edit/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchPlaylistsRequest generates requests for SearchPlaylists
func NewSearchPlaylistsRequest(server string, params *SearchPlaylistsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/playlist/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, params.Query); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFetchPlaylistRequest generates requests for FetchPlaylist
func NewFetchPlaylistRequest(server string, playlistMbid openapi_types.UUID, params *FetchPlaylistParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "playlist_mbid", runtime.ParamLocationPath, playlistMbid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/playlist/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FetchMetadata != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fetch_metadata", runtime.ParamLocationQuery, *params.FetchMetadata); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCopyPlaylistRequest generates requests for CopyPlaylist
func NewCopyPlaylistRequest(server string, playlistMbid openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "playlist_mbid", runtime.ParamLocationPath, playlistMbid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/playlist/%s/copy", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeletePlaylistRequest generates requests for DeletePlaylist
func NewDeletePlaylistRequest(server string, playlistMbid openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "playlist_mbid", runtime.ParamLocationPath, playlistMbid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/playlist/%s/delete", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppendRecordingsRequest calls the generic AppendRecordings builder with application/json body
func NewAppendRecordingsRequest(server string, playlistMbid openapi_types.UUID, offset int, body AppendRecordingsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAppendRecordingsRequestWithBody(server, playlistMbid, offset, "application/json", bodyReader)
}

// NewAppendRecordingsRequestWithBody generates requests for AppendRecordings with any type of body
func NewAppendRecordingsRequestWithBody(server string, playlistMbid openapi_types.UUID, offset int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "playlist_mbid", runtime.ParamLocationPath, playlistMbid)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "offset", runtime.ParamLocationPath, offset)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/playlist/%s/item/add/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewItemDeleteRequest calls the generic ItemDelete builder with application/json body
func NewItemDeleteRequest(server string, playlistMbid openapi_types.UUID, body ItemDeleteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewItemDeleteRequestWithBody(server, playlistMbid, "application/json", bodyReader)
}

// NewItemDeleteRequestWithBody generates requests for ItemDelete with any type of body
func NewItemDeleteRequestWithBody(server string, playlistMbid openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "playlist_mbid", runtime.ParamLocationPath, playlistMbid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/playlist/%s/item/delete", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMoveItemRequest calls the generic MoveItem builder with application/json body
func NewMoveItemRequest(server string, playlistMbid openapi_types.UUID, body MoveItemJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMoveItemRequestWithBody(server, playlistMbid, "application/json", bodyReader)
}

// NewMoveItemRequestWithBody generates requests for MoveItem with any type of body
func NewMoveItemRequestWithBody(server string, playlistMbid openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "playlist_mbid", runtime.ParamLocationPath, playlistMbid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/playlist/%s/item/move", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewArtistRequest calls the generic Artist builder with application/json body
func NewArtistRequest(server string, body ArtistJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewArtistRequestWithBody(server, "application/json", bodyReader)
}

// NewArtistRequestWithBody generates requests for Artist with any type of body
func NewArtistRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/popularity/artist")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRecordingRequest calls the generic Recording builder with application/json body
func NewRecordingRequest(server string, body RecordingJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRecordingRequestWithBody(server, "application/json", bodyReader)
}

// NewRecordingRequestWithBody generates requests for Recording with any type of body
func NewRecordingRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/popularity/recording")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReleaseRequest calls the generic Release builder with application/json body
func NewReleaseRequest(server string, body ReleaseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReleaseRequestWithBody(server, "application/json", bodyReader)
}

// NewReleaseRequestWithBody generates requests for Release with any type of body
func NewReleaseRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/popularity/release")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReleaseGroupRequest calls the generic ReleaseGroup builder with application/json body
func NewReleaseGroupRequest(server string, body ReleaseGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReleaseGroupRequestWithBody(server, "application/json", bodyReader)
}

// NewReleaseGroupRequestWithBody generates requests for ReleaseGroup with any type of body
func NewReleaseGroupRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/popularity/release-group")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTopRecordingsForArtistRequest generates requests for TopRecordingsForArtist
func NewTopRecordingsForArtistRequest(server string, artistMbid openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "artist_mbid", runtime.ParamLocationPath, artistMbid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/popularity/top-recordings-for-artist/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTopReleaseGroupForArtistRequest generates requests for TopReleaseGroupForArtist
func NewTopReleaseGroupForArtistRequest(server string, artistMbid openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "artist_mbid", runtime.ParamLocationPath, artistMbid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/popularity/top-release-groups-for-artist/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSubmitFeedbackRequest calls the generic SubmitFeedback builder with application/json body
func NewSubmitFeedbackRequest(server string, body SubmitFeedbackJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSubmitFeedbackRequestWithBody(server, "application/json", bodyReader)
}

// NewSubmitFeedbackRequestWithBody generates requests for SubmitFeedback with any type of body
func NewSubmitFeedbackRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/recommendation/feedback/submit")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteFeedbackRequest calls the generic DeleteFeedback builder with application/json body
func NewDeleteFeedbackRequest(server string, body DeleteFeedbackJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteFeedbackRequestWithBody(server, "application/json", bodyReader)
}

// NewDeleteFeedbackRequestWithBody generates requests for DeleteFeedback with any type of body
func NewDeleteFeedbackRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/recommendations/feedback/delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFeedbackGivenByRequest generates requests for FeedbackGivenBy
func NewFeedbackGivenByRequest(server string, userName string, params *FeedbackGivenByParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_name", runtime.ParamLocationPath, userName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/recommendations/feedback/user/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Rating != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "rating", runtime.ParamLocationQuery, *params.Rating); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Count != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRecordingsFeedbackGivenByRequest generates requests for RecordingsFeedbackGivenBy
func NewRecordingsFeedbackGivenByRequest(server string, userName string, params *RecordingsFeedbackGivenByParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_name", runtime.ParamLocationPath, userName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/recommendations/feedback/user/%s/recordings", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mbids", runtime.ParamLocationQuery, params.Mbids); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchUsersRequest generates requests for SearchUsers
func NewSearchUsersRequest(server string, params *SearchUsersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/search/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search_term", runtime.ParamLocationQuery, params.SearchTerm); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListenersForArtistRequest generates requests for ListenersForArtist
func NewListenersForArtistRequest(server string, artistMbid openapi_types.UUID, params *ListenersForArtistParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "artist_mbid", runtime.ParamLocationPath, artistMbid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/stats/artist/%s/listeners", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Range != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "range", runtime.ParamLocationQuery, *params.Range); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListenersForReleaseGroupRequest generates requests for ListenersForReleaseGroup
func NewListenersForReleaseGroupRequest(server string, releaseGroupMbid openapi_types.UUID, params *ListenersForReleaseGroupParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "release_group_mbid", runtime.ParamLocationPath, releaseGroupMbid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/stats/release-group/%s/listeners", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Range != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "range", runtime.ParamLocationQuery, *params.Range); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSitewideArtistMapRequest generates requests for SitewideArtistMap
func NewSitewideArtistMapRequest(server string, params *SitewideArtistMapParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/stats/sitewide/artist-map")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Range != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "range", runtime.ParamLocationQuery, *params.Range); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceRecalculate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_recalculate", runtime.ParamLocationQuery, *params.ForceRecalculate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSitewideTopArtistsRequest generates requests for SitewideTopArtists
func NewSitewideTopArtistsRequest(server string, params *SitewideTopArtistsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/stats/sitewide/artists")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Count != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Range != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "range", runtime.ParamLocationQuery, *params.Range); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSitewideListeningActivityRequest generates requests for SitewideListeningActivity
func NewSitewideListeningActivityRequest(server string, params *SitewideListeningActivityParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/stats/sitewide/listening-activity")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Range != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "range", runtime.ParamLocationQuery, *params.Range); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSitewideTopRecordingsRequest generates requests for SitewideTopRecordings
func NewSitewideTopRecordingsRequest(server string, params *SitewideTopRecordingsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/stats/sitewide/recordings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Count != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Range != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "range", runtime.ParamLocationQuery, *params.Range); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSitewideTopReleaseGroupsRequest generates requests for SitewideTopReleaseGroups
func NewSitewideTopReleaseGroupsRequest(server string, params *SitewideTopReleaseGroupsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/stats/sitewide/release-groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Count != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Range != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "range", runtime.ParamLocationQuery, *params.Range); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSitewideTopReleasesRequest generates requests for SitewideTopReleases
func NewSitewideTopReleasesRequest(server string, params *SitewideTopReleasesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/stats/sitewide/releases")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Count != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Range != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "range", runtime.ParamLocationQuery, *params.Range); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewArtistMapForUserRequest generates requests for ArtistMapForUser
func NewArtistMapForUserRequest(server string, userName string, params *ArtistMapForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_name", runtime.ParamLocationPath, userName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/stats/user/%s/artist-map", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Range != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "range", runtime.ParamLocationQuery, *params.Range); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceRecalculate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_recalculate", runtime.ParamLocationQuery, *params.ForceRecalculate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTopArtistsForUserRequest generates requests for TopArtistsForUser
func NewTopArtistsForUserRequest(server string, userName string, params *TopArtistsForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_name", runtime.ParamLocationPath, userName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/stats/user/%s/artists", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Count != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Range != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "range", runtime.ParamLocationQuery, *params.Range); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDailyActivityForUserRequest generates requests for DailyActivityForUser
func NewDailyActivityForUserRequest(server string, userName string, params *DailyActivityForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_name", runtime.ParamLocationPath, userName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/stats/user/%s/daily-activity", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Range != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "range", runtime.ParamLocationQuery, *params.Range); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListeningActivityForUserRequest generates requests for ListeningActivityForUser
func NewListeningActivityForUserRequest(server string, userName string, params *ListeningActivityForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_name", runtime.ParamLocationPath, userName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/stats/user/%s/listening-activity", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Range != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "range", runtime.ParamLocationQuery, *params.Range); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTopRecordingsForUserRequest generates requests for TopRecordingsForUser
func NewTopRecordingsForUserRequest(server string, userName string, params *TopRecordingsForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_name", runtime.ParamLocationPath, userName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/stats/user/%s/recordings", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Count != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Range != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "range", runtime.ParamLocationQuery, *params.Range); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTopReleaseGroupsForUserRequest generates requests for TopReleaseGroupsForUser
func NewTopReleaseGroupsForUserRequest(server string, userName string, params *TopReleaseGroupsForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_name", runtime.ParamLocationPath, userName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/stats/user/%s/release-groups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Count != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Range != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "range", runtime.ParamLocationQuery, *params.Range); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTopReleasesForUserRequest generates requests for TopReleasesForUser
func NewTopReleasesForUserRequest(server string, userName string, params *TopReleasesForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_name", runtime.ParamLocationPath, userName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/stats/user/%s/releases", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Count != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Range != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "range", runtime.ParamLocationQuery, *params.Range); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewYearInMusicForUserRequest generates requests for YearInMusicForUser
func NewYearInMusicForUserRequest(server string, userName string, year int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_name", runtime.ParamLocationPath, userName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "year", runtime.ParamLocationPath, year)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/stats/user/%s/year-in-music/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDumpInfoRequest generates requests for GetDumpInfo
func NewGetDumpInfoRequest(server string, params *GetDumpInfoParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/status/get-dump-info")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSubmitListensRequest calls the generic SubmitListens builder with application/json body
func NewSubmitListensRequest(server string, body SubmitListensJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSubmitListensRequestWithBody(server, "application/json", bodyReader)
}

// NewSubmitListensRequestWithBody generates requests for SubmitListens with any type of body
func NewSubmitListensRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/submit-listens")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnpinRequest generates requests for Unpin
func NewUnpinRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/unpin")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPlaylistsForUserRequest generates requests for PlaylistsForUser
func NewPlaylistsForUserRequest(server string, playlistUserName string, params *PlaylistsForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "playlist_user_name", runtime.ParamLocationPath, playlistUserName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/user/%s/playlists", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Count != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPlaylistsForUserCollaboratorRequest generates requests for PlaylistsForUserCollaborator
func NewPlaylistsForUserCollaboratorRequest(server string, playlistUserName string, params *PlaylistsForUserCollaboratorParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "playlist_user_name", runtime.ParamLocationPath, playlistUserName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/user/%s/playlists/collaborator", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Count != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPlaylistsCreatedForUserRequest generates requests for PlaylistsCreatedForUser
func NewPlaylistsCreatedForUserRequest(server string, playlistUserName string, params *PlaylistsCreatedForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "playlist_user_name", runtime.ParamLocationPath, playlistUserName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/user/%s/playlists/createdfor", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Count != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRecommendationPlaylistsForUserRequest generates requests for RecommendationPlaylistsForUser
func NewRecommendationPlaylistsForUserRequest(server string, playlistUserName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "playlist_user_name", runtime.ParamLocationPath, playlistUserName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/user/%s/playlists/recommendations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchPlaylistForUserRequest generates requests for SearchPlaylistForUser
func NewSearchPlaylistForUserRequest(server string, playlistUserName string, params *SearchPlaylistForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "playlist_user_name", runtime.ParamLocationPath, playlistUserName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/user/%s/playlists/search", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, params.Query); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Count != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFeedEventsRequest generates requests for FeedEvents
func NewFeedEventsRequest(server string, userName string, params *FeedEventsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_name", runtime.ParamLocationPath, userName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/user/%s/feed/events", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.MaxTs != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_ts", runtime.ParamLocationQuery, *params.MaxTs); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinTs != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_ts", runtime.ParamLocationQuery, *params.MinTs); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Count != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFeedEventsDeleteRequest calls the generic FeedEventsDelete builder with application/json body
func NewFeedEventsDeleteRequest(server string, userName string, body FeedEventsDeleteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFeedEventsDeleteRequestWithBody(server, userName, "application/json", bodyReader)
}

// NewFeedEventsDeleteRequestWithBody generates requests for FeedEventsDelete with any type of body
func NewFeedEventsDeleteRequestWithBody(server string, userName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_name", runtime.ParamLocationPath, userName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/user/%s/feed/events/delete", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFeedEventsHideRequest calls the generic FeedEventsHide builder with application/json body
func NewFeedEventsHideRequest(server string, userName string, body FeedEventsHideJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFeedEventsHideRequestWithBody(server, userName, "application/json", bodyReader)
}

// NewFeedEventsHideRequestWithBody generates requests for FeedEventsHide with any type of body
func NewFeedEventsHideRequestWithBody(server string, userName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_name", runtime.ParamLocationPath, userName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/user/%s/feed/events/hide", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFeedEventsListensFollowingRequest generates requests for FeedEventsListensFollowing
func NewFeedEventsListensFollowingRequest(server string, userName string, params *FeedEventsListensFollowingParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_name", runtime.ParamLocationPath, userName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/user/%s/feed/events/listens/following", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.MaxTs != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_ts", runtime.ParamLocationQuery, *params.MaxTs); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinTs != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_ts", runtime.ParamLocationQuery, *params.MinTs); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Count != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFeedEventsListensSimilarRequest generates requests for FeedEventsListensSimilar
func NewFeedEventsListensSimilarRequest(server string, userName string, params *FeedEventsListensSimilarParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_name", runtime.ParamLocationPath, userName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/user/%s/feed/events/listens/similar", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.MaxTs != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_ts", runtime.ParamLocationQuery, *params.MaxTs); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinTs != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_ts", runtime.ParamLocationQuery, *params.MinTs); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Count != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFeedEventsUnhideRequest calls the generic FeedEventsUnhide builder with application/json body
func NewFeedEventsUnhideRequest(server string, userName string, body FeedEventsUnhideJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFeedEventsUnhideRequestWithBody(server, userName, "application/json", bodyReader)
}

// NewFeedEventsUnhideRequestWithBody generates requests for FeedEventsUnhide with any type of body
func NewFeedEventsUnhideRequestWithBody(server string, userName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_name", runtime.ParamLocationPath, userName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/user/%s/feed/events/unhide", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFollowRequest generates requests for Follow
func NewFollowRequest(server string, userName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_name", runtime.ParamLocationPath, userName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/user/%s/follow", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFollowersRequest generates requests for Followers
func NewFollowersRequest(server string, userName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_name", runtime.ParamLocationPath, userName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/user/%s/followers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFollowingRequest generates requests for Following
func NewFollowingRequest(server string, userName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_name", runtime.ParamLocationPath, userName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/user/%s/following", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListenCountForUserRequest generates requests for ListenCountForUser
func NewListenCountForUserRequest(server string, userName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_name", runtime.ParamLocationPath, userName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/user/%s/listen-count", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListensForUserRequest generates requests for ListensForUser
func NewListensForUserRequest(server string, userName string, params *ListensForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_name", runtime.ParamLocationPath, userName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/user/%s/listens", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.MaxTs != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_ts", runtime.ParamLocationQuery, *params.MaxTs); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinTs != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_ts", runtime.ParamLocationQuery, *params.MinTs); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Count != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPlayingNowForUserRequest generates requests for PlayingNowForUser
func NewPlayingNowForUserRequest(server string, userName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_name", runtime.ParamLocationPath, userName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/user/%s/playing-now", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewServicesForUserRequest generates requests for ServicesForUser
func NewServicesForUserRequest(server string, userName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_name", runtime.ParamLocationPath, userName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/user/%s/services", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSimilarityOfUserForUserRequest generates requests for SimilarityOfUserForUser
func NewSimilarityOfUserForUserRequest(server string, userName string, otherUserName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_name", runtime.ParamLocationPath, userName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "other_user_name", runtime.ParamLocationPath, otherUserName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/user/%s/similar-to/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSimilarUsersForUserRequest generates requests for SimilarUsersForUser
func NewSimilarUsersForUserRequest(server string, userName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_name", runtime.ParamLocationPath, userName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/user/%s/similar-users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateNotificationRequest calls the generic CreateNotification builder with application/json body
func NewCreateNotificationRequest(server string, userName string, body CreateNotificationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateNotificationRequestWithBody(server, userName, "application/json", bodyReader)
}

// NewCreateNotificationRequestWithBody generates requests for CreateNotification with any type of body
func NewCreateNotificationRequestWithBody(server string, userName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_name", runtime.ParamLocationPath, userName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/user/%s/timeline-event/create/notification", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRecommendPersonalRecordingRequest calls the generic RecommendPersonalRecording builder with application/json body
func NewRecommendPersonalRecordingRequest(server string, userName string, body RecommendPersonalRecordingJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRecommendPersonalRecordingRequestWithBody(server, userName, "application/json", bodyReader)
}

// NewRecommendPersonalRecordingRequestWithBody generates requests for RecommendPersonalRecording with any type of body
func NewRecommendPersonalRecordingRequestWithBody(server string, userName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_name", runtime.ParamLocationPath, userName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/user/%s/timeline-event/create/recommend-personal", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRecommendRecordingRequest calls the generic RecommendRecording builder with application/json body
func NewRecommendRecordingRequest(server string, userName string, body RecommendRecordingJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRecommendRecordingRequestWithBody(server, userName, "application/json", bodyReader)
}

// NewRecommendRecordingRequestWithBody generates requests for RecommendRecording with any type of body
func NewRecommendRecordingRequestWithBody(server string, userName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_name", runtime.ParamLocationPath, userName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/user/%s/timeline-event/create/recording", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateReviewRequest calls the generic CreateReview builder with application/json body
func NewCreateReviewRequest(server string, userName string, body CreateReviewJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateReviewRequestWithBody(server, userName, "application/json", bodyReader)
}

// NewCreateReviewRequestWithBody generates requests for CreateReview with any type of body
func NewCreateReviewRequestWithBody(server string, userName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_name", runtime.ParamLocationPath, userName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/user/%s/timeline-event/create/review", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnfollowRequest generates requests for Unfollow
func NewUnfollowRequest(server string, userName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_name", runtime.ParamLocationPath, userName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/user/%s/unfollow", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewValidateTokenRequest generates requests for ValidateToken
func NewValidateTokenRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/validate-token")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPinsRequest generates requests for GetPins
func NewGetPinsRequest(server string, userName string, params *GetPinsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_name", runtime.ParamLocationPath, userName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/%s/pins", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Count != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPinsCurrentRequest generates requests for GetPinsCurrent
func NewGetPinsCurrentRequest(server string, userName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_name", runtime.ParamLocationPath, userName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/%s/pins/current", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPinsFollowingRequest generates requests for GetPinsFollowing
func NewGetPinsFollowingRequest(server string, userName string, params *GetPinsFollowingParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_name", runtime.ParamLocationPath, userName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/1/%s/pins/following", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Count != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// CreateCoverArtGridForUserWithResponse request
	CreateCoverArtGridForUserWithResponse(ctx context.Context, userName string, timeRange AllowedStatisticsRange, dimension int, layout int, imageSize int, reqEditors ...RequestEditorFn) (*CreateCoverArtGridForUserResponse, error)

	// CreateCoverArtGridWithBodyWithResponse request with any body
	CreateCoverArtGridWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCoverArtGridResponse, error)

	CreateCoverArtGridWithResponse(ctx context.Context, body CreateCoverArtGridJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCoverArtGridResponse, error)

	// YearInMusicWithResponse request
	YearInMusicWithResponse(ctx context.Context, year int, userName string, params *YearInMusicParams, reqEditors ...RequestEditorFn) (*YearInMusicResponse, error)

	// CreateCustomCoverArtWithResponse request
	CreateCustomCoverArtWithResponse(ctx context.Context, customName CoverTypes, userName string, timeRange AllowedStatisticsRange, imageSize int, reqEditors ...RequestEditorFn) (*CreateCustomCoverArtResponse, error)

	// RecordingRecommendationsWithResponse request
	RecordingRecommendationsWithResponse(ctx context.Context, userName string, params *RecordingRecommendationsParams, reqEditors ...RequestEditorFn) (*RecordingRecommendationsResponse, error)

	// DeleteListenWithBodyWithResponse request with any body
	DeleteListenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteListenResponse, error)

	DeleteListenWithResponse(ctx context.Context, body DeleteListenJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteListenResponse, error)

	// ColorWithResponse request
	ColorWithResponse(ctx context.Context, color string, reqEditors ...RequestEditorFn) (*ColorResponse, error)

	// FreshReleasesWithResponse request
	FreshReleasesWithResponse(ctx context.Context, params *FreshReleasesParams, reqEditors ...RequestEditorFn) (*FreshReleasesResponse, error)

	// LbRadioWithResponse request
	LbRadioWithResponse(ctx context.Context, params *LbRadioParams, reqEditors ...RequestEditorFn) (*LbRadioResponse, error)

	// RecordingFeedbackWithBodyWithResponse request with any body
	RecordingFeedbackWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RecordingFeedbackResponse, error)

	RecordingFeedbackWithResponse(ctx context.Context, body RecordingFeedbackJSONRequestBody, reqEditors ...RequestEditorFn) (*RecordingFeedbackResponse, error)

	// GetFeedbackMbidWithResponse request
	GetFeedbackMbidWithResponse(ctx context.Context, recordingMbid openapi_types.UUID, params *GetFeedbackMbidParams, reqEditors ...RequestEditorFn) (*GetFeedbackMbidResponse, error)

	// GetFeedbackMsidWithResponse request
	GetFeedbackMsidWithResponse(ctx context.Context, recordingMsid string, params *GetFeedbackMsidParams, reqEditors ...RequestEditorFn) (*GetFeedbackMsidResponse, error)

	// GetFeedbackWithResponse request
	GetFeedbackWithResponse(ctx context.Context, userName string, params *GetFeedbackParams, reqEditors ...RequestEditorFn) (*GetFeedbackResponse, error)

	// GetFeedbackForRecordingsWithResponse request
	GetFeedbackForRecordingsWithResponse(ctx context.Context, userName string, params *GetFeedbackForRecordingsParams, reqEditors ...RequestEditorFn) (*GetFeedbackForRecordingsResponse, error)

	// LatestImportWithResponse request
	LatestImportWithResponse(ctx context.Context, params *LatestImportParams, reqEditors ...RequestEditorFn) (*LatestImportResponse, error)

	// LbRadioRecordingsForArtistWithResponse request
	LbRadioRecordingsForArtistWithResponse(ctx context.Context, seedArtistMbid openapi_types.UUID, params *LbRadioRecordingsForArtistParams, reqEditors ...RequestEditorFn) (*LbRadioRecordingsForArtistResponse, error)

	// LbRadioTagsWithResponse request
	LbRadioTagsWithResponse(ctx context.Context, params *LbRadioTagsParams, reqEditors ...RequestEditorFn) (*LbRadioTagsResponse, error)

	// ArtistMetadataWithResponse request
	ArtistMetadataWithResponse(ctx context.Context, params *ArtistMetadataParams, reqEditors ...RequestEditorFn) (*ArtistMetadataResponse, error)

	// GetManualMappingWithResponse request
	GetManualMappingWithResponse(ctx context.Context, params *GetManualMappingParams, reqEditors ...RequestEditorFn) (*GetManualMappingResponse, error)

	// LookupWithResponse request
	LookupWithResponse(ctx context.Context, params *LookupParams, reqEditors ...RequestEditorFn) (*LookupResponse, error)

	// RecordingMetadataWithResponse request
	RecordingMetadataWithResponse(ctx context.Context, params *RecordingMetadataParams, reqEditors ...RequestEditorFn) (*RecordingMetadataResponse, error)

	// ReleaseGroupMetadataWithResponse request
	ReleaseGroupMetadataWithResponse(ctx context.Context, params *ReleaseGroupMetadataParams, reqEditors ...RequestEditorFn) (*ReleaseGroupMetadataResponse, error)

	// SubmitManualMappingWithBodyWithResponse request with any body
	SubmitManualMappingWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SubmitManualMappingResponse, error)

	SubmitManualMappingWithResponse(ctx context.Context, body SubmitManualMappingJSONRequestBody, reqEditors ...RequestEditorFn) (*SubmitManualMappingResponse, error)

	// PinWithBodyWithResponse request with any body
	PinWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PinResponse, error)

	PinWithResponse(ctx context.Context, body PinJSONRequestBody, reqEditors ...RequestEditorFn) (*PinResponse, error)

	// PinDeleteWithResponse request
	PinDeleteWithResponse(ctx context.Context, rowId int, reqEditors ...RequestEditorFn) (*PinDeleteResponse, error)

	// UpdatePinWithBodyWithResponse request with any body
	UpdatePinWithBodyWithResponse(ctx context.Context, rowId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePinResponse, error)

	UpdatePinWithResponse(ctx context.Context, rowId int, body UpdatePinJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePinResponse, error)

	// CreatePlaylistWithBodyWithResponse request with any body
	CreatePlaylistWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePlaylistResponse, error)

	CreatePlaylistWithResponse(ctx context.Context, body CreatePlaylistJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePlaylistResponse, error)

	// EditPlaylistWithBodyWithResponse request with any body
	EditPlaylistWithBodyWithResponse(ctx context.Context, playlistMbid openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditPlaylistResponse, error)

	EditPlaylistWithResponse(ctx context.Context, playlistMbid openapi_types.UUID, body EditPlaylistJSONRequestBody, reqEditors ...RequestEditorFn) (*EditPlaylistResponse, error)

	// SearchPlaylistsWithResponse request
	SearchPlaylistsWithResponse(ctx context.Context, params *SearchPlaylistsParams, reqEditors ...RequestEditorFn) (*SearchPlaylistsResponse, error)

	// FetchPlaylistWithResponse request
	FetchPlaylistWithResponse(ctx context.Context, playlistMbid openapi_types.UUID, params *FetchPlaylistParams, reqEditors ...RequestEditorFn) (*FetchPlaylistResponse, error)

	// CopyPlaylistWithResponse request
	CopyPlaylistWithResponse(ctx context.Context, playlistMbid openapi_types.UUID, reqEditors ...RequestEditorFn) (*CopyPlaylistResponse, error)

	// DeletePlaylistWithResponse request
	DeletePlaylistWithResponse(ctx context.Context, playlistMbid openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeletePlaylistResponse, error)

	// AppendRecordingsWithBodyWithResponse request with any body
	AppendRecordingsWithBodyWithResponse(ctx context.Context, playlistMbid openapi_types.UUID, offset int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AppendRecordingsResponse, error)

	AppendRecordingsWithResponse(ctx context.Context, playlistMbid openapi_types.UUID, offset int, body AppendRecordingsJSONRequestBody, reqEditors ...RequestEditorFn) (*AppendRecordingsResponse, error)

	// ItemDeleteWithBodyWithResponse request with any body
	ItemDeleteWithBodyWithResponse(ctx context.Context, playlistMbid openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ItemDeleteResponse, error)

	ItemDeleteWithResponse(ctx context.Context, playlistMbid openapi_types.UUID, body ItemDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*ItemDeleteResponse, error)

	// MoveItemWithBodyWithResponse request with any body
	MoveItemWithBodyWithResponse(ctx context.Context, playlistMbid openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MoveItemResponse, error)

	MoveItemWithResponse(ctx context.Context, playlistMbid openapi_types.UUID, body MoveItemJSONRequestBody, reqEditors ...RequestEditorFn) (*MoveItemResponse, error)

	// ArtistWithBodyWithResponse request with any body
	ArtistWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArtistResponse, error)

	ArtistWithResponse(ctx context.Context, body ArtistJSONRequestBody, reqEditors ...RequestEditorFn) (*ArtistResponse, error)

	// RecordingWithBodyWithResponse request with any body
	RecordingWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RecordingResponse, error)

	RecordingWithResponse(ctx context.Context, body RecordingJSONRequestBody, reqEditors ...RequestEditorFn) (*RecordingResponse, error)

	// ReleaseWithBodyWithResponse request with any body
	ReleaseWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReleaseResponse, error)

	ReleaseWithResponse(ctx context.Context, body ReleaseJSONRequestBody, reqEditors ...RequestEditorFn) (*ReleaseResponse, error)

	// ReleaseGroupWithBodyWithResponse request with any body
	ReleaseGroupWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReleaseGroupResponse, error)

	ReleaseGroupWithResponse(ctx context.Context, body ReleaseGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*ReleaseGroupResponse, error)

	// TopRecordingsForArtistWithResponse request
	TopRecordingsForArtistWithResponse(ctx context.Context, artistMbid openapi_types.UUID, reqEditors ...RequestEditorFn) (*TopRecordingsForArtistResponse, error)

	// TopReleaseGroupForArtistWithResponse request
	TopReleaseGroupForArtistWithResponse(ctx context.Context, artistMbid openapi_types.UUID, reqEditors ...RequestEditorFn) (*TopReleaseGroupForArtistResponse, error)

	// SubmitFeedbackWithBodyWithResponse request with any body
	SubmitFeedbackWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SubmitFeedbackResponse, error)

	SubmitFeedbackWithResponse(ctx context.Context, body SubmitFeedbackJSONRequestBody, reqEditors ...RequestEditorFn) (*SubmitFeedbackResponse, error)

	// DeleteFeedbackWithBodyWithResponse request with any body
	DeleteFeedbackWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteFeedbackResponse, error)

	DeleteFeedbackWithResponse(ctx context.Context, body DeleteFeedbackJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteFeedbackResponse, error)

	// FeedbackGivenByWithResponse request
	FeedbackGivenByWithResponse(ctx context.Context, userName string, params *FeedbackGivenByParams, reqEditors ...RequestEditorFn) (*FeedbackGivenByResponse, error)

	// RecordingsFeedbackGivenByWithResponse request
	RecordingsFeedbackGivenByWithResponse(ctx context.Context, userName string, params *RecordingsFeedbackGivenByParams, reqEditors ...RequestEditorFn) (*RecordingsFeedbackGivenByResponse, error)

	// SearchUsersWithResponse request
	SearchUsersWithResponse(ctx context.Context, params *SearchUsersParams, reqEditors ...RequestEditorFn) (*SearchUsersResponse, error)

	// ListenersForArtistWithResponse request
	ListenersForArtistWithResponse(ctx context.Context, artistMbid openapi_types.UUID, params *ListenersForArtistParams, reqEditors ...RequestEditorFn) (*ListenersForArtistResponse, error)

	// ListenersForReleaseGroupWithResponse request
	ListenersForReleaseGroupWithResponse(ctx context.Context, releaseGroupMbid openapi_types.UUID, params *ListenersForReleaseGroupParams, reqEditors ...RequestEditorFn) (*ListenersForReleaseGroupResponse, error)

	// SitewideArtistMapWithResponse request
	SitewideArtistMapWithResponse(ctx context.Context, params *SitewideArtistMapParams, reqEditors ...RequestEditorFn) (*SitewideArtistMapResponse, error)

	// SitewideTopArtistsWithResponse request
	SitewideTopArtistsWithResponse(ctx context.Context, params *SitewideTopArtistsParams, reqEditors ...RequestEditorFn) (*SitewideTopArtistsResponse, error)

	// SitewideListeningActivityWithResponse request
	SitewideListeningActivityWithResponse(ctx context.Context, params *SitewideListeningActivityParams, reqEditors ...RequestEditorFn) (*SitewideListeningActivityResponse, error)

	// SitewideTopRecordingsWithResponse request
	SitewideTopRecordingsWithResponse(ctx context.Context, params *SitewideTopRecordingsParams, reqEditors ...RequestEditorFn) (*SitewideTopRecordingsResponse, error)

	// SitewideTopReleaseGroupsWithResponse request
	SitewideTopReleaseGroupsWithResponse(ctx context.Context, params *SitewideTopReleaseGroupsParams, reqEditors ...RequestEditorFn) (*SitewideTopReleaseGroupsResponse, error)

	// SitewideTopReleasesWithResponse request
	SitewideTopReleasesWithResponse(ctx context.Context, params *SitewideTopReleasesParams, reqEditors ...RequestEditorFn) (*SitewideTopReleasesResponse, error)

	// ArtistMapForUserWithResponse request
	ArtistMapForUserWithResponse(ctx context.Context, userName string, params *ArtistMapForUserParams, reqEditors ...RequestEditorFn) (*ArtistMapForUserResponse, error)

	// TopArtistsForUserWithResponse request
	TopArtistsForUserWithResponse(ctx context.Context, userName string, params *TopArtistsForUserParams, reqEditors ...RequestEditorFn) (*TopArtistsForUserResponse, error)

	// DailyActivityForUserWithResponse request
	DailyActivityForUserWithResponse(ctx context.Context, userName string, params *DailyActivityForUserParams, reqEditors ...RequestEditorFn) (*DailyActivityForUserResponse, error)

	// ListeningActivityForUserWithResponse request
	ListeningActivityForUserWithResponse(ctx context.Context, userName string, params *ListeningActivityForUserParams, reqEditors ...RequestEditorFn) (*ListeningActivityForUserResponse, error)

	// TopRecordingsForUserWithResponse request
	TopRecordingsForUserWithResponse(ctx context.Context, userName string, params *TopRecordingsForUserParams, reqEditors ...RequestEditorFn) (*TopRecordingsForUserResponse, error)

	// TopReleaseGroupsForUserWithResponse request
	TopReleaseGroupsForUserWithResponse(ctx context.Context, userName string, params *TopReleaseGroupsForUserParams, reqEditors ...RequestEditorFn) (*TopReleaseGroupsForUserResponse, error)

	// TopReleasesForUserWithResponse request
	TopReleasesForUserWithResponse(ctx context.Context, userName string, params *TopReleasesForUserParams, reqEditors ...RequestEditorFn) (*TopReleasesForUserResponse, error)

	// YearInMusicForUserWithResponse request
	YearInMusicForUserWithResponse(ctx context.Context, userName string, year int, reqEditors ...RequestEditorFn) (*YearInMusicForUserResponse, error)

	// GetDumpInfoWithResponse request
	GetDumpInfoWithResponse(ctx context.Context, params *GetDumpInfoParams, reqEditors ...RequestEditorFn) (*GetDumpInfoResponse, error)

	// SubmitListensWithBodyWithResponse request with any body
	SubmitListensWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SubmitListensResponse, error)

	SubmitListensWithResponse(ctx context.Context, body SubmitListensJSONRequestBody, reqEditors ...RequestEditorFn) (*SubmitListensResponse, error)

	// UnpinWithResponse request
	UnpinWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UnpinResponse, error)

	// PlaylistsForUserWithResponse request
	PlaylistsForUserWithResponse(ctx context.Context, playlistUserName string, params *PlaylistsForUserParams, reqEditors ...RequestEditorFn) (*PlaylistsForUserResponse, error)

	// PlaylistsForUserCollaboratorWithResponse request
	PlaylistsForUserCollaboratorWithResponse(ctx context.Context, playlistUserName string, params *PlaylistsForUserCollaboratorParams, reqEditors ...RequestEditorFn) (*PlaylistsForUserCollaboratorResponse, error)

	// PlaylistsCreatedForUserWithResponse request
	PlaylistsCreatedForUserWithResponse(ctx context.Context, playlistUserName string, params *PlaylistsCreatedForUserParams, reqEditors ...RequestEditorFn) (*PlaylistsCreatedForUserResponse, error)

	// RecommendationPlaylistsForUserWithResponse request
	RecommendationPlaylistsForUserWithResponse(ctx context.Context, playlistUserName string, reqEditors ...RequestEditorFn) (*RecommendationPlaylistsForUserResponse, error)

	// SearchPlaylistForUserWithResponse request
	SearchPlaylistForUserWithResponse(ctx context.Context, playlistUserName string, params *SearchPlaylistForUserParams, reqEditors ...RequestEditorFn) (*SearchPlaylistForUserResponse, error)

	// FeedEventsWithResponse request
	FeedEventsWithResponse(ctx context.Context, userName string, params *FeedEventsParams, reqEditors ...RequestEditorFn) (*FeedEventsResponse, error)

	// FeedEventsDeleteWithBodyWithResponse request with any body
	FeedEventsDeleteWithBodyWithResponse(ctx context.Context, userName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FeedEventsDeleteResponse, error)

	FeedEventsDeleteWithResponse(ctx context.Context, userName string, body FeedEventsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*FeedEventsDeleteResponse, error)

	// FeedEventsHideWithBodyWithResponse request with any body
	FeedEventsHideWithBodyWithResponse(ctx context.Context, userName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FeedEventsHideResponse, error)

	FeedEventsHideWithResponse(ctx context.Context, userName string, body FeedEventsHideJSONRequestBody, reqEditors ...RequestEditorFn) (*FeedEventsHideResponse, error)

	// FeedEventsListensFollowingWithResponse request
	FeedEventsListensFollowingWithResponse(ctx context.Context, userName string, params *FeedEventsListensFollowingParams, reqEditors ...RequestEditorFn) (*FeedEventsListensFollowingResponse, error)

	// FeedEventsListensSimilarWithResponse request
	FeedEventsListensSimilarWithResponse(ctx context.Context, userName string, params *FeedEventsListensSimilarParams, reqEditors ...RequestEditorFn) (*FeedEventsListensSimilarResponse, error)

	// FeedEventsUnhideWithBodyWithResponse request with any body
	FeedEventsUnhideWithBodyWithResponse(ctx context.Context, userName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FeedEventsUnhideResponse, error)

	FeedEventsUnhideWithResponse(ctx context.Context, userName string, body FeedEventsUnhideJSONRequestBody, reqEditors ...RequestEditorFn) (*FeedEventsUnhideResponse, error)

	// FollowWithResponse request
	FollowWithResponse(ctx context.Context, userName string, reqEditors ...RequestEditorFn) (*FollowResponse, error)

	// FollowersWithResponse request
	FollowersWithResponse(ctx context.Context, userName string, reqEditors ...RequestEditorFn) (*FollowersResponse, error)

	// FollowingWithResponse request
	FollowingWithResponse(ctx context.Context, userName string, reqEditors ...RequestEditorFn) (*FollowingResponse, error)

	// ListenCountForUserWithResponse request
	ListenCountForUserWithResponse(ctx context.Context, userName string, reqEditors ...RequestEditorFn) (*ListenCountForUserResponse, error)

	// ListensForUserWithResponse request
	ListensForUserWithResponse(ctx context.Context, userName string, params *ListensForUserParams, reqEditors ...RequestEditorFn) (*ListensForUserResponse, error)

	// PlayingNowForUserWithResponse request
	PlayingNowForUserWithResponse(ctx context.Context, userName string, reqEditors ...RequestEditorFn) (*PlayingNowForUserResponse, error)

	// ServicesForUserWithResponse request
	ServicesForUserWithResponse(ctx context.Context, userName string, reqEditors ...RequestEditorFn) (*ServicesForUserResponse, error)

	// SimilarityOfUserForUserWithResponse request
	SimilarityOfUserForUserWithResponse(ctx context.Context, userName string, otherUserName string, reqEditors ...RequestEditorFn) (*SimilarityOfUserForUserResponse, error)

	// SimilarUsersForUserWithResponse request
	SimilarUsersForUserWithResponse(ctx context.Context, userName string, reqEditors ...RequestEditorFn) (*SimilarUsersForUserResponse, error)

	// CreateNotificationWithBodyWithResponse request with any body
	CreateNotificationWithBodyWithResponse(ctx context.Context, userName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNotificationResponse, error)

	CreateNotificationWithResponse(ctx context.Context, userName string, body CreateNotificationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNotificationResponse, error)

	// RecommendPersonalRecordingWithBodyWithResponse request with any body
	RecommendPersonalRecordingWithBodyWithResponse(ctx context.Context, userName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RecommendPersonalRecordingResponse, error)

	RecommendPersonalRecordingWithResponse(ctx context.Context, userName string, body RecommendPersonalRecordingJSONRequestBody, reqEditors ...RequestEditorFn) (*RecommendPersonalRecordingResponse, error)

	// RecommendRecordingWithBodyWithResponse request with any body
	RecommendRecordingWithBodyWithResponse(ctx context.Context, userName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RecommendRecordingResponse, error)

	RecommendRecordingWithResponse(ctx context.Context, userName string, body RecommendRecordingJSONRequestBody, reqEditors ...RequestEditorFn) (*RecommendRecordingResponse, error)

	// CreateReviewWithBodyWithResponse request with any body
	CreateReviewWithBodyWithResponse(ctx context.Context, userName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateReviewResponse, error)

	CreateReviewWithResponse(ctx context.Context, userName string, body CreateReviewJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateReviewResponse, error)

	// UnfollowWithResponse request
	UnfollowWithResponse(ctx context.Context, userName string, reqEditors ...RequestEditorFn) (*UnfollowResponse, error)

	// ValidateTokenWithResponse request
	ValidateTokenWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ValidateTokenResponse, error)

	// GetPinsWithResponse request
	GetPinsWithResponse(ctx context.Context, userName string, params *GetPinsParams, reqEditors ...RequestEditorFn) (*GetPinsResponse, error)

	// GetPinsCurrentWithResponse request
	GetPinsCurrentWithResponse(ctx context.Context, userName string, reqEditors ...RequestEditorFn) (*GetPinsCurrentResponse, error)

	// GetPinsFollowingWithResponse request
	GetPinsFollowingWithResponse(ctx context.Context, userName string, params *GetPinsFollowingParams, reqEditors ...RequestEditorFn) (*GetPinsFollowingResponse, error)
}

type CreateCoverArtGridForUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateCoverArtGridForUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCoverArtGridForUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateCoverArtGridResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateCoverArtGridResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCoverArtGridResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type YearInMusicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r YearInMusicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r YearInMusicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateCustomCoverArtResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateCustomCoverArtResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCustomCoverArtResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RecordingRecommendationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RecordingRecommendations
}

// Status returns HTTPResponse.Status
func (r RecordingRecommendationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RecordingRecommendationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteListenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteListenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteListenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ColorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Color
}

// Status returns HTTPResponse.Status
func (r ColorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ColorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FreshReleasesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FreshReleases
}

// Status returns HTTPResponse.Status
func (r FreshReleasesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FreshReleasesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LbRadioResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LbRadio
}

// Status returns HTTPResponse.Status
func (r LbRadioResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LbRadioResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RecordingFeedbackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RecordingFeedbackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RecordingFeedbackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFeedbackMbidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FeedbackResponse
}

// Status returns HTTPResponse.Status
func (r GetFeedbackMbidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFeedbackMbidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFeedbackMsidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FeedbackResponse
}

// Status returns HTTPResponse.Status
func (r GetFeedbackMsidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFeedbackMsidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFeedbackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FeedbackResponse
}

// Status returns HTTPResponse.Status
func (r GetFeedbackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFeedbackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFeedbackForRecordingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FeedbackResponse
}

// Status returns HTTPResponse.Status
func (r GetFeedbackForRecordingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFeedbackForRecordingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LatestImportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LatestImport
}

// Status returns HTTPResponse.Status
func (r LatestImportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LatestImportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LbRadioRecordingsForArtistResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LbRadioRecordingsForArtist
}

// Status returns HTTPResponse.Status
func (r LbRadioRecordingsForArtistResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LbRadioRecordingsForArtistResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LbRadioTagsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LbRadioTags
}

// Status returns HTTPResponse.Status
func (r LbRadioTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LbRadioTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArtistMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ArtistMetadata
}

// Status returns HTTPResponse.Status
func (r ArtistMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArtistMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetManualMappingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetManualMapping
}

// Status returns HTTPResponse.Status
func (r GetManualMappingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetManualMappingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LookupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Lookup
}

// Status returns HTTPResponse.Status
func (r LookupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LookupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RecordingMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]RecordingMetadata
}

// Status returns HTTPResponse.Status
func (r RecordingMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RecordingMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReleaseGroupMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]ReleaseGroupMetadata
}

// Status returns HTTPResponse.Status
func (r ReleaseGroupMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReleaseGroupMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SubmitManualMappingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SubmitManualMappingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SubmitManualMappingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PinResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Pin200Response
}

// Status returns HTTPResponse.Status
func (r PinResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PinResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PinDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PinDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PinDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePinResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdatePinResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePinResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePlaylistResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreatePlaylist200Response
}

// Status returns HTTPResponse.Status
func (r CreatePlaylistResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePlaylistResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EditPlaylistResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r EditPlaylistResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EditPlaylistResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchPlaylistsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Playlists
}

// Status returns HTTPResponse.Status
func (r SearchPlaylistsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchPlaylistsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FetchPlaylistResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreatePlaylistRequest
}

// Status returns HTTPResponse.Status
func (r FetchPlaylistResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchPlaylistResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CopyPlaylistResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CopyPlaylistResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CopyPlaylistResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePlaylistResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeletePlaylistResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePlaylistResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppendRecordingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AppendRecordingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppendRecordingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ItemDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ItemDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ItemDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MoveItemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r MoveItemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MoveItemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArtistResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Artist200ResponseInner
}

// Status returns HTTPResponse.Status
func (r ArtistResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArtistResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RecordingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Recording200ResponseInner
}

// Status returns HTTPResponse.Status
func (r RecordingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RecordingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReleaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Release200ResponseInner
}

// Status returns HTTPResponse.Status
func (r ReleaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReleaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReleaseGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ReleaseGroup200ResponseInner
}

// Status returns HTTPResponse.Status
func (r ReleaseGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReleaseGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TopRecordingsForArtistResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TopRecordingsForArtist
}

// Status returns HTTPResponse.Status
func (r TopRecordingsForArtistResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TopRecordingsForArtistResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TopReleaseGroupForArtistResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TopReleaseGroupsForArtist
}

// Status returns HTTPResponse.Status
func (r TopReleaseGroupForArtistResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TopReleaseGroupForArtistResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SubmitFeedbackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SubmitFeedbackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SubmitFeedbackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteFeedbackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteFeedbackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFeedbackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FeedbackGivenByResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FeedbackGivenBy
}

// Status returns HTTPResponse.Status
func (r FeedbackGivenByResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FeedbackGivenByResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RecordingsFeedbackGivenByResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RecordingsFeedbackGivenBy
}

// Status returns HTTPResponse.Status
func (r RecordingsFeedbackGivenByResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RecordingsFeedbackGivenByResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SearchUsers
}

// Status returns HTTPResponse.Status
func (r SearchUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListenersForArtistResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListenersForArtist
}

// Status returns HTTPResponse.Status
func (r ListenersForArtistResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListenersForArtistResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListenersForReleaseGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListenersForReleaseGroup
}

// Status returns HTTPResponse.Status
func (r ListenersForReleaseGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListenersForReleaseGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SitewideArtistMapResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SitewideArtistMap
}

// Status returns HTTPResponse.Status
func (r SitewideArtistMapResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SitewideArtistMapResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SitewideTopArtistsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SitewideTopArtists
}

// Status returns HTTPResponse.Status
func (r SitewideTopArtistsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SitewideTopArtistsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SitewideListeningActivityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SitewideListeningActivity
}

// Status returns HTTPResponse.Status
func (r SitewideListeningActivityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SitewideListeningActivityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SitewideTopRecordingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SitewideTopRecordings
}

// Status returns HTTPResponse.Status
func (r SitewideTopRecordingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SitewideTopRecordingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SitewideTopReleaseGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SitewideTopReleaseGroups
}

// Status returns HTTPResponse.Status
func (r SitewideTopReleaseGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SitewideTopReleaseGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SitewideTopReleasesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SitewideTopReleases
}

// Status returns HTTPResponse.Status
func (r SitewideTopReleasesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SitewideTopReleasesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArtistMapForUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArtistMapForUser
}

// Status returns HTTPResponse.Status
func (r ArtistMapForUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArtistMapForUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TopArtistsForUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TopArtistsForUser
}

// Status returns HTTPResponse.Status
func (r TopArtistsForUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TopArtistsForUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DailyActivityForUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DailyActivityForUser
}

// Status returns HTTPResponse.Status
func (r DailyActivityForUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DailyActivityForUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListeningActivityForUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListeningActivityForUser
}

// Status returns HTTPResponse.Status
func (r ListeningActivityForUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListeningActivityForUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TopRecordingsForUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TopRecordingsForUser
}

// Status returns HTTPResponse.Status
func (r TopRecordingsForUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TopRecordingsForUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TopReleaseGroupsForUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TopReleaseGroupsForUser
}

// Status returns HTTPResponse.Status
func (r TopReleaseGroupsForUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TopReleaseGroupsForUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TopReleasesForUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TopReleasesForUser
}

// Status returns HTTPResponse.Status
func (r TopReleasesForUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TopReleasesForUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type YearInMusicForUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *YearInMusicForUser
}

// Status returns HTTPResponse.Status
func (r YearInMusicForUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r YearInMusicForUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDumpInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetDumpInfo
}

// Status returns HTTPResponse.Status
func (r GetDumpInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDumpInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SubmitListensResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SubmitListensResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SubmitListensResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnpinResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UnpinResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnpinResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PlaylistsForUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Playlists
}

// Status returns HTTPResponse.Status
func (r PlaylistsForUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PlaylistsForUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PlaylistsForUserCollaboratorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Playlists
}

// Status returns HTTPResponse.Status
func (r PlaylistsForUserCollaboratorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PlaylistsForUserCollaboratorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PlaylistsCreatedForUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Playlists
}

// Status returns HTTPResponse.Status
func (r PlaylistsCreatedForUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PlaylistsCreatedForUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RecommendationPlaylistsForUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Playlists
}

// Status returns HTTPResponse.Status
func (r RecommendationPlaylistsForUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RecommendationPlaylistsForUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchPlaylistForUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Playlists
}

// Status returns HTTPResponse.Status
func (r SearchPlaylistForUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchPlaylistForUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FeedEventsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FeedEvents
}

// Status returns HTTPResponse.Status
func (r FeedEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FeedEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FeedEventsDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r FeedEventsDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FeedEventsDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FeedEventsHideResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r FeedEventsHideResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FeedEventsHideResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FeedEventsListensFollowingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FeedEvents
}

// Status returns HTTPResponse.Status
func (r FeedEventsListensFollowingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FeedEventsListensFollowingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FeedEventsListensSimilarResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FeedEventsListensSimilar
}

// Status returns HTTPResponse.Status
func (r FeedEventsListensSimilarResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FeedEventsListensSimilarResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FeedEventsUnhideResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r FeedEventsUnhideResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FeedEventsUnhideResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FollowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r FollowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FollowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FollowersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Followers
}

// Status returns HTTPResponse.Status
func (r FollowersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FollowersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FollowingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Following
}

// Status returns HTTPResponse.Status
func (r FollowingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FollowingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListenCountForUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListenCountForUser
}

// Status returns HTTPResponse.Status
func (r ListenCountForUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListenCountForUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListensForUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListensForUser
}

// Status returns HTTPResponse.Status
func (r ListensForUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListensForUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PlayingNowForUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PlayingNowForUser
}

// Status returns HTTPResponse.Status
func (r PlayingNowForUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PlayingNowForUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ServicesForUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServicesForUser
}

// Status returns HTTPResponse.Status
func (r ServicesForUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ServicesForUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SimilarityOfUserForUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SimilarityOfUserForUser
}

// Status returns HTTPResponse.Status
func (r SimilarityOfUserForUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SimilarityOfUserForUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SimilarUsersForUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SimilarUsersForUser
}

// Status returns HTTPResponse.Status
func (r SimilarUsersForUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SimilarUsersForUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateNotificationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateNotificationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateNotificationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RecommendPersonalRecordingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RecommendPersonalRecordingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RecommendPersonalRecordingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RecommendRecordingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RecommendRecordingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RecommendRecordingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateReviewResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateReviewResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateReviewResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnfollowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UnfollowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnfollowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ValidateTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ValidateToken
}

// Status returns HTTPResponse.Status
func (r ValidateTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ValidateTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPinsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetPins
}

// Status returns HTTPResponse.Status
func (r GetPinsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPinsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPinsCurrentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetPinsCurrent200Response
}

// Status returns HTTPResponse.Status
func (r GetPinsCurrentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPinsCurrentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPinsFollowingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetPins
}

// Status returns HTTPResponse.Status
func (r GetPinsFollowingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPinsFollowingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// CreateCoverArtGridForUserWithResponse request returning *CreateCoverArtGridForUserResponse
func (c *ClientWithResponses) CreateCoverArtGridForUserWithResponse(ctx context.Context, userName string, timeRange AllowedStatisticsRange, dimension int, layout int, imageSize int, reqEditors ...RequestEditorFn) (*CreateCoverArtGridForUserResponse, error) {
	rsp, err := c.CreateCoverArtGridForUser(ctx, userName, timeRange, dimension, layout, imageSize, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCoverArtGridForUserResponse(rsp)
}

// CreateCoverArtGridWithBodyWithResponse request with arbitrary body returning *CreateCoverArtGridResponse
func (c *ClientWithResponses) CreateCoverArtGridWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCoverArtGridResponse, error) {
	rsp, err := c.CreateCoverArtGridWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCoverArtGridResponse(rsp)
}

func (c *ClientWithResponses) CreateCoverArtGridWithResponse(ctx context.Context, body CreateCoverArtGridJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCoverArtGridResponse, error) {
	rsp, err := c.CreateCoverArtGrid(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCoverArtGridResponse(rsp)
}

// YearInMusicWithResponse request returning *YearInMusicResponse
func (c *ClientWithResponses) YearInMusicWithResponse(ctx context.Context, year int, userName string, params *YearInMusicParams, reqEditors ...RequestEditorFn) (*YearInMusicResponse, error) {
	rsp, err := c.YearInMusic(ctx, year, userName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseYearInMusicResponse(rsp)
}

// CreateCustomCoverArtWithResponse request returning *CreateCustomCoverArtResponse
func (c *ClientWithResponses) CreateCustomCoverArtWithResponse(ctx context.Context, customName CoverTypes, userName string, timeRange AllowedStatisticsRange, imageSize int, reqEditors ...RequestEditorFn) (*CreateCustomCoverArtResponse, error) {
	rsp, err := c.CreateCustomCoverArt(ctx, customName, userName, timeRange, imageSize, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCustomCoverArtResponse(rsp)
}

// RecordingRecommendationsWithResponse request returning *RecordingRecommendationsResponse
func (c *ClientWithResponses) RecordingRecommendationsWithResponse(ctx context.Context, userName string, params *RecordingRecommendationsParams, reqEditors ...RequestEditorFn) (*RecordingRecommendationsResponse, error) {
	rsp, err := c.RecordingRecommendations(ctx, userName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRecordingRecommendationsResponse(rsp)
}

// DeleteListenWithBodyWithResponse request with arbitrary body returning *DeleteListenResponse
func (c *ClientWithResponses) DeleteListenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteListenResponse, error) {
	rsp, err := c.DeleteListenWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteListenResponse(rsp)
}

func (c *ClientWithResponses) DeleteListenWithResponse(ctx context.Context, body DeleteListenJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteListenResponse, error) {
	rsp, err := c.DeleteListen(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteListenResponse(rsp)
}

// ColorWithResponse request returning *ColorResponse
func (c *ClientWithResponses) ColorWithResponse(ctx context.Context, color string, reqEditors ...RequestEditorFn) (*ColorResponse, error) {
	rsp, err := c.Color(ctx, color, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseColorResponse(rsp)
}

// FreshReleasesWithResponse request returning *FreshReleasesResponse
func (c *ClientWithResponses) FreshReleasesWithResponse(ctx context.Context, params *FreshReleasesParams, reqEditors ...RequestEditorFn) (*FreshReleasesResponse, error) {
	rsp, err := c.FreshReleases(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFreshReleasesResponse(rsp)
}

// LbRadioWithResponse request returning *LbRadioResponse
func (c *ClientWithResponses) LbRadioWithResponse(ctx context.Context, params *LbRadioParams, reqEditors ...RequestEditorFn) (*LbRadioResponse, error) {
	rsp, err := c.LbRadio(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLbRadioResponse(rsp)
}

// RecordingFeedbackWithBodyWithResponse request with arbitrary body returning *RecordingFeedbackResponse
func (c *ClientWithResponses) RecordingFeedbackWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RecordingFeedbackResponse, error) {
	rsp, err := c.RecordingFeedbackWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRecordingFeedbackResponse(rsp)
}

func (c *ClientWithResponses) RecordingFeedbackWithResponse(ctx context.Context, body RecordingFeedbackJSONRequestBody, reqEditors ...RequestEditorFn) (*RecordingFeedbackResponse, error) {
	rsp, err := c.RecordingFeedback(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRecordingFeedbackResponse(rsp)
}

// GetFeedbackMbidWithResponse request returning *GetFeedbackMbidResponse
func (c *ClientWithResponses) GetFeedbackMbidWithResponse(ctx context.Context, recordingMbid openapi_types.UUID, params *GetFeedbackMbidParams, reqEditors ...RequestEditorFn) (*GetFeedbackMbidResponse, error) {
	rsp, err := c.GetFeedbackMbid(ctx, recordingMbid, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFeedbackMbidResponse(rsp)
}

// GetFeedbackMsidWithResponse request returning *GetFeedbackMsidResponse
func (c *ClientWithResponses) GetFeedbackMsidWithResponse(ctx context.Context, recordingMsid string, params *GetFeedbackMsidParams, reqEditors ...RequestEditorFn) (*GetFeedbackMsidResponse, error) {
	rsp, err := c.GetFeedbackMsid(ctx, recordingMsid, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFeedbackMsidResponse(rsp)
}

// GetFeedbackWithResponse request returning *GetFeedbackResponse
func (c *ClientWithResponses) GetFeedbackWithResponse(ctx context.Context, userName string, params *GetFeedbackParams, reqEditors ...RequestEditorFn) (*GetFeedbackResponse, error) {
	rsp, err := c.GetFeedback(ctx, userName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFeedbackResponse(rsp)
}

// GetFeedbackForRecordingsWithResponse request returning *GetFeedbackForRecordingsResponse
func (c *ClientWithResponses) GetFeedbackForRecordingsWithResponse(ctx context.Context, userName string, params *GetFeedbackForRecordingsParams, reqEditors ...RequestEditorFn) (*GetFeedbackForRecordingsResponse, error) {
	rsp, err := c.GetFeedbackForRecordings(ctx, userName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFeedbackForRecordingsResponse(rsp)
}

// LatestImportWithResponse request returning *LatestImportResponse
func (c *ClientWithResponses) LatestImportWithResponse(ctx context.Context, params *LatestImportParams, reqEditors ...RequestEditorFn) (*LatestImportResponse, error) {
	rsp, err := c.LatestImport(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLatestImportResponse(rsp)
}

// LbRadioRecordingsForArtistWithResponse request returning *LbRadioRecordingsForArtistResponse
func (c *ClientWithResponses) LbRadioRecordingsForArtistWithResponse(ctx context.Context, seedArtistMbid openapi_types.UUID, params *LbRadioRecordingsForArtistParams, reqEditors ...RequestEditorFn) (*LbRadioRecordingsForArtistResponse, error) {
	rsp, err := c.LbRadioRecordingsForArtist(ctx, seedArtistMbid, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLbRadioRecordingsForArtistResponse(rsp)
}

// LbRadioTagsWithResponse request returning *LbRadioTagsResponse
func (c *ClientWithResponses) LbRadioTagsWithResponse(ctx context.Context, params *LbRadioTagsParams, reqEditors ...RequestEditorFn) (*LbRadioTagsResponse, error) {
	rsp, err := c.LbRadioTags(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLbRadioTagsResponse(rsp)
}

// ArtistMetadataWithResponse request returning *ArtistMetadataResponse
func (c *ClientWithResponses) ArtistMetadataWithResponse(ctx context.Context, params *ArtistMetadataParams, reqEditors ...RequestEditorFn) (*ArtistMetadataResponse, error) {
	rsp, err := c.ArtistMetadata(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArtistMetadataResponse(rsp)
}

// GetManualMappingWithResponse request returning *GetManualMappingResponse
func (c *ClientWithResponses) GetManualMappingWithResponse(ctx context.Context, params *GetManualMappingParams, reqEditors ...RequestEditorFn) (*GetManualMappingResponse, error) {
	rsp, err := c.GetManualMapping(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetManualMappingResponse(rsp)
}

// LookupWithResponse request returning *LookupResponse
func (c *ClientWithResponses) LookupWithResponse(ctx context.Context, params *LookupParams, reqEditors ...RequestEditorFn) (*LookupResponse, error) {
	rsp, err := c.Lookup(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLookupResponse(rsp)
}

// RecordingMetadataWithResponse request returning *RecordingMetadataResponse
func (c *ClientWithResponses) RecordingMetadataWithResponse(ctx context.Context, params *RecordingMetadataParams, reqEditors ...RequestEditorFn) (*RecordingMetadataResponse, error) {
	rsp, err := c.RecordingMetadata(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRecordingMetadataResponse(rsp)
}

// ReleaseGroupMetadataWithResponse request returning *ReleaseGroupMetadataResponse
func (c *ClientWithResponses) ReleaseGroupMetadataWithResponse(ctx context.Context, params *ReleaseGroupMetadataParams, reqEditors ...RequestEditorFn) (*ReleaseGroupMetadataResponse, error) {
	rsp, err := c.ReleaseGroupMetadata(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReleaseGroupMetadataResponse(rsp)
}

// SubmitManualMappingWithBodyWithResponse request with arbitrary body returning *SubmitManualMappingResponse
func (c *ClientWithResponses) SubmitManualMappingWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SubmitManualMappingResponse, error) {
	rsp, err := c.SubmitManualMappingWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSubmitManualMappingResponse(rsp)
}

func (c *ClientWithResponses) SubmitManualMappingWithResponse(ctx context.Context, body SubmitManualMappingJSONRequestBody, reqEditors ...RequestEditorFn) (*SubmitManualMappingResponse, error) {
	rsp, err := c.SubmitManualMapping(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSubmitManualMappingResponse(rsp)
}

// PinWithBodyWithResponse request with arbitrary body returning *PinResponse
func (c *ClientWithResponses) PinWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PinResponse, error) {
	rsp, err := c.PinWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePinResponse(rsp)
}

func (c *ClientWithResponses) PinWithResponse(ctx context.Context, body PinJSONRequestBody, reqEditors ...RequestEditorFn) (*PinResponse, error) {
	rsp, err := c.Pin(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePinResponse(rsp)
}

// PinDeleteWithResponse request returning *PinDeleteResponse
func (c *ClientWithResponses) PinDeleteWithResponse(ctx context.Context, rowId int, reqEditors ...RequestEditorFn) (*PinDeleteResponse, error) {
	rsp, err := c.PinDelete(ctx, rowId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePinDeleteResponse(rsp)
}

// UpdatePinWithBodyWithResponse request with arbitrary body returning *UpdatePinResponse
func (c *ClientWithResponses) UpdatePinWithBodyWithResponse(ctx context.Context, rowId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePinResponse, error) {
	rsp, err := c.UpdatePinWithBody(ctx, rowId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePinResponse(rsp)
}

func (c *ClientWithResponses) UpdatePinWithResponse(ctx context.Context, rowId int, body UpdatePinJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePinResponse, error) {
	rsp, err := c.UpdatePin(ctx, rowId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePinResponse(rsp)
}

// CreatePlaylistWithBodyWithResponse request with arbitrary body returning *CreatePlaylistResponse
func (c *ClientWithResponses) CreatePlaylistWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePlaylistResponse, error) {
	rsp, err := c.CreatePlaylistWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePlaylistResponse(rsp)
}

func (c *ClientWithResponses) CreatePlaylistWithResponse(ctx context.Context, body CreatePlaylistJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePlaylistResponse, error) {
	rsp, err := c.CreatePlaylist(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePlaylistResponse(rsp)
}

// EditPlaylistWithBodyWithResponse request with arbitrary body returning *EditPlaylistResponse
func (c *ClientWithResponses) EditPlaylistWithBodyWithResponse(ctx context.Context, playlistMbid openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditPlaylistResponse, error) {
	rsp, err := c.EditPlaylistWithBody(ctx, playlistMbid, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditPlaylistResponse(rsp)
}

func (c *ClientWithResponses) EditPlaylistWithResponse(ctx context.Context, playlistMbid openapi_types.UUID, body EditPlaylistJSONRequestBody, reqEditors ...RequestEditorFn) (*EditPlaylistResponse, error) {
	rsp, err := c.EditPlaylist(ctx, playlistMbid, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditPlaylistResponse(rsp)
}

// SearchPlaylistsWithResponse request returning *SearchPlaylistsResponse
func (c *ClientWithResponses) SearchPlaylistsWithResponse(ctx context.Context, params *SearchPlaylistsParams, reqEditors ...RequestEditorFn) (*SearchPlaylistsResponse, error) {
	rsp, err := c.SearchPlaylists(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchPlaylistsResponse(rsp)
}

// FetchPlaylistWithResponse request returning *FetchPlaylistResponse
func (c *ClientWithResponses) FetchPlaylistWithResponse(ctx context.Context, playlistMbid openapi_types.UUID, params *FetchPlaylistParams, reqEditors ...RequestEditorFn) (*FetchPlaylistResponse, error) {
	rsp, err := c.FetchPlaylist(ctx, playlistMbid, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFetchPlaylistResponse(rsp)
}

// CopyPlaylistWithResponse request returning *CopyPlaylistResponse
func (c *ClientWithResponses) CopyPlaylistWithResponse(ctx context.Context, playlistMbid openapi_types.UUID, reqEditors ...RequestEditorFn) (*CopyPlaylistResponse, error) {
	rsp, err := c.CopyPlaylist(ctx, playlistMbid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCopyPlaylistResponse(rsp)
}

// DeletePlaylistWithResponse request returning *DeletePlaylistResponse
func (c *ClientWithResponses) DeletePlaylistWithResponse(ctx context.Context, playlistMbid openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeletePlaylistResponse, error) {
	rsp, err := c.DeletePlaylist(ctx, playlistMbid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePlaylistResponse(rsp)
}

// AppendRecordingsWithBodyWithResponse request with arbitrary body returning *AppendRecordingsResponse
func (c *ClientWithResponses) AppendRecordingsWithBodyWithResponse(ctx context.Context, playlistMbid openapi_types.UUID, offset int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AppendRecordingsResponse, error) {
	rsp, err := c.AppendRecordingsWithBody(ctx, playlistMbid, offset, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppendRecordingsResponse(rsp)
}

func (c *ClientWithResponses) AppendRecordingsWithResponse(ctx context.Context, playlistMbid openapi_types.UUID, offset int, body AppendRecordingsJSONRequestBody, reqEditors ...RequestEditorFn) (*AppendRecordingsResponse, error) {
	rsp, err := c.AppendRecordings(ctx, playlistMbid, offset, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppendRecordingsResponse(rsp)
}

// ItemDeleteWithBodyWithResponse request with arbitrary body returning *ItemDeleteResponse
func (c *ClientWithResponses) ItemDeleteWithBodyWithResponse(ctx context.Context, playlistMbid openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ItemDeleteResponse, error) {
	rsp, err := c.ItemDeleteWithBody(ctx, playlistMbid, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseItemDeleteResponse(rsp)
}

func (c *ClientWithResponses) ItemDeleteWithResponse(ctx context.Context, playlistMbid openapi_types.UUID, body ItemDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*ItemDeleteResponse, error) {
	rsp, err := c.ItemDelete(ctx, playlistMbid, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseItemDeleteResponse(rsp)
}

// MoveItemWithBodyWithResponse request with arbitrary body returning *MoveItemResponse
func (c *ClientWithResponses) MoveItemWithBodyWithResponse(ctx context.Context, playlistMbid openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MoveItemResponse, error) {
	rsp, err := c.MoveItemWithBody(ctx, playlistMbid, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMoveItemResponse(rsp)
}

func (c *ClientWithResponses) MoveItemWithResponse(ctx context.Context, playlistMbid openapi_types.UUID, body MoveItemJSONRequestBody, reqEditors ...RequestEditorFn) (*MoveItemResponse, error) {
	rsp, err := c.MoveItem(ctx, playlistMbid, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMoveItemResponse(rsp)
}

// ArtistWithBodyWithResponse request with arbitrary body returning *ArtistResponse
func (c *ClientWithResponses) ArtistWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArtistResponse, error) {
	rsp, err := c.ArtistWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArtistResponse(rsp)
}

func (c *ClientWithResponses) ArtistWithResponse(ctx context.Context, body ArtistJSONRequestBody, reqEditors ...RequestEditorFn) (*ArtistResponse, error) {
	rsp, err := c.Artist(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArtistResponse(rsp)
}

// RecordingWithBodyWithResponse request with arbitrary body returning *RecordingResponse
func (c *ClientWithResponses) RecordingWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RecordingResponse, error) {
	rsp, err := c.RecordingWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRecordingResponse(rsp)
}

func (c *ClientWithResponses) RecordingWithResponse(ctx context.Context, body RecordingJSONRequestBody, reqEditors ...RequestEditorFn) (*RecordingResponse, error) {
	rsp, err := c.Recording(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRecordingResponse(rsp)
}

// ReleaseWithBodyWithResponse request with arbitrary body returning *ReleaseResponse
func (c *ClientWithResponses) ReleaseWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReleaseResponse, error) {
	rsp, err := c.ReleaseWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReleaseResponse(rsp)
}

func (c *ClientWithResponses) ReleaseWithResponse(ctx context.Context, body ReleaseJSONRequestBody, reqEditors ...RequestEditorFn) (*ReleaseResponse, error) {
	rsp, err := c.Release(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReleaseResponse(rsp)
}

// ReleaseGroupWithBodyWithResponse request with arbitrary body returning *ReleaseGroupResponse
func (c *ClientWithResponses) ReleaseGroupWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReleaseGroupResponse, error) {
	rsp, err := c.ReleaseGroupWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReleaseGroupResponse(rsp)
}

func (c *ClientWithResponses) ReleaseGroupWithResponse(ctx context.Context, body ReleaseGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*ReleaseGroupResponse, error) {
	rsp, err := c.ReleaseGroup(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReleaseGroupResponse(rsp)
}

// TopRecordingsForArtistWithResponse request returning *TopRecordingsForArtistResponse
func (c *ClientWithResponses) TopRecordingsForArtistWithResponse(ctx context.Context, artistMbid openapi_types.UUID, reqEditors ...RequestEditorFn) (*TopRecordingsForArtistResponse, error) {
	rsp, err := c.TopRecordingsForArtist(ctx, artistMbid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTopRecordingsForArtistResponse(rsp)
}

// TopReleaseGroupForArtistWithResponse request returning *TopReleaseGroupForArtistResponse
func (c *ClientWithResponses) TopReleaseGroupForArtistWithResponse(ctx context.Context, artistMbid openapi_types.UUID, reqEditors ...RequestEditorFn) (*TopReleaseGroupForArtistResponse, error) {
	rsp, err := c.TopReleaseGroupForArtist(ctx, artistMbid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTopReleaseGroupForArtistResponse(rsp)
}

// SubmitFeedbackWithBodyWithResponse request with arbitrary body returning *SubmitFeedbackResponse
func (c *ClientWithResponses) SubmitFeedbackWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SubmitFeedbackResponse, error) {
	rsp, err := c.SubmitFeedbackWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSubmitFeedbackResponse(rsp)
}

func (c *ClientWithResponses) SubmitFeedbackWithResponse(ctx context.Context, body SubmitFeedbackJSONRequestBody, reqEditors ...RequestEditorFn) (*SubmitFeedbackResponse, error) {
	rsp, err := c.SubmitFeedback(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSubmitFeedbackResponse(rsp)
}

// DeleteFeedbackWithBodyWithResponse request with arbitrary body returning *DeleteFeedbackResponse
func (c *ClientWithResponses) DeleteFeedbackWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteFeedbackResponse, error) {
	rsp, err := c.DeleteFeedbackWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFeedbackResponse(rsp)
}

func (c *ClientWithResponses) DeleteFeedbackWithResponse(ctx context.Context, body DeleteFeedbackJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteFeedbackResponse, error) {
	rsp, err := c.DeleteFeedback(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFeedbackResponse(rsp)
}

// FeedbackGivenByWithResponse request returning *FeedbackGivenByResponse
func (c *ClientWithResponses) FeedbackGivenByWithResponse(ctx context.Context, userName string, params *FeedbackGivenByParams, reqEditors ...RequestEditorFn) (*FeedbackGivenByResponse, error) {
	rsp, err := c.FeedbackGivenBy(ctx, userName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFeedbackGivenByResponse(rsp)
}

// RecordingsFeedbackGivenByWithResponse request returning *RecordingsFeedbackGivenByResponse
func (c *ClientWithResponses) RecordingsFeedbackGivenByWithResponse(ctx context.Context, userName string, params *RecordingsFeedbackGivenByParams, reqEditors ...RequestEditorFn) (*RecordingsFeedbackGivenByResponse, error) {
	rsp, err := c.RecordingsFeedbackGivenBy(ctx, userName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRecordingsFeedbackGivenByResponse(rsp)
}

// SearchUsersWithResponse request returning *SearchUsersResponse
func (c *ClientWithResponses) SearchUsersWithResponse(ctx context.Context, params *SearchUsersParams, reqEditors ...RequestEditorFn) (*SearchUsersResponse, error) {
	rsp, err := c.SearchUsers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchUsersResponse(rsp)
}

// ListenersForArtistWithResponse request returning *ListenersForArtistResponse
func (c *ClientWithResponses) ListenersForArtistWithResponse(ctx context.Context, artistMbid openapi_types.UUID, params *ListenersForArtistParams, reqEditors ...RequestEditorFn) (*ListenersForArtistResponse, error) {
	rsp, err := c.ListenersForArtist(ctx, artistMbid, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListenersForArtistResponse(rsp)
}

// ListenersForReleaseGroupWithResponse request returning *ListenersForReleaseGroupResponse
func (c *ClientWithResponses) ListenersForReleaseGroupWithResponse(ctx context.Context, releaseGroupMbid openapi_types.UUID, params *ListenersForReleaseGroupParams, reqEditors ...RequestEditorFn) (*ListenersForReleaseGroupResponse, error) {
	rsp, err := c.ListenersForReleaseGroup(ctx, releaseGroupMbid, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListenersForReleaseGroupResponse(rsp)
}

// SitewideArtistMapWithResponse request returning *SitewideArtistMapResponse
func (c *ClientWithResponses) SitewideArtistMapWithResponse(ctx context.Context, params *SitewideArtistMapParams, reqEditors ...RequestEditorFn) (*SitewideArtistMapResponse, error) {
	rsp, err := c.SitewideArtistMap(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSitewideArtistMapResponse(rsp)
}

// SitewideTopArtistsWithResponse request returning *SitewideTopArtistsResponse
func (c *ClientWithResponses) SitewideTopArtistsWithResponse(ctx context.Context, params *SitewideTopArtistsParams, reqEditors ...RequestEditorFn) (*SitewideTopArtistsResponse, error) {
	rsp, err := c.SitewideTopArtists(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSitewideTopArtistsResponse(rsp)
}

// SitewideListeningActivityWithResponse request returning *SitewideListeningActivityResponse
func (c *ClientWithResponses) SitewideListeningActivityWithResponse(ctx context.Context, params *SitewideListeningActivityParams, reqEditors ...RequestEditorFn) (*SitewideListeningActivityResponse, error) {
	rsp, err := c.SitewideListeningActivity(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSitewideListeningActivityResponse(rsp)
}

// SitewideTopRecordingsWithResponse request returning *SitewideTopRecordingsResponse
func (c *ClientWithResponses) SitewideTopRecordingsWithResponse(ctx context.Context, params *SitewideTopRecordingsParams, reqEditors ...RequestEditorFn) (*SitewideTopRecordingsResponse, error) {
	rsp, err := c.SitewideTopRecordings(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSitewideTopRecordingsResponse(rsp)
}

// SitewideTopReleaseGroupsWithResponse request returning *SitewideTopReleaseGroupsResponse
func (c *ClientWithResponses) SitewideTopReleaseGroupsWithResponse(ctx context.Context, params *SitewideTopReleaseGroupsParams, reqEditors ...RequestEditorFn) (*SitewideTopReleaseGroupsResponse, error) {
	rsp, err := c.SitewideTopReleaseGroups(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSitewideTopReleaseGroupsResponse(rsp)
}

// SitewideTopReleasesWithResponse request returning *SitewideTopReleasesResponse
func (c *ClientWithResponses) SitewideTopReleasesWithResponse(ctx context.Context, params *SitewideTopReleasesParams, reqEditors ...RequestEditorFn) (*SitewideTopReleasesResponse, error) {
	rsp, err := c.SitewideTopReleases(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSitewideTopReleasesResponse(rsp)
}

// ArtistMapForUserWithResponse request returning *ArtistMapForUserResponse
func (c *ClientWithResponses) ArtistMapForUserWithResponse(ctx context.Context, userName string, params *ArtistMapForUserParams, reqEditors ...RequestEditorFn) (*ArtistMapForUserResponse, error) {
	rsp, err := c.ArtistMapForUser(ctx, userName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArtistMapForUserResponse(rsp)
}

// TopArtistsForUserWithResponse request returning *TopArtistsForUserResponse
func (c *ClientWithResponses) TopArtistsForUserWithResponse(ctx context.Context, userName string, params *TopArtistsForUserParams, reqEditors ...RequestEditorFn) (*TopArtistsForUserResponse, error) {
	rsp, err := c.TopArtistsForUser(ctx, userName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTopArtistsForUserResponse(rsp)
}

// DailyActivityForUserWithResponse request returning *DailyActivityForUserResponse
func (c *ClientWithResponses) DailyActivityForUserWithResponse(ctx context.Context, userName string, params *DailyActivityForUserParams, reqEditors ...RequestEditorFn) (*DailyActivityForUserResponse, error) {
	rsp, err := c.DailyActivityForUser(ctx, userName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDailyActivityForUserResponse(rsp)
}

// ListeningActivityForUserWithResponse request returning *ListeningActivityForUserResponse
func (c *ClientWithResponses) ListeningActivityForUserWithResponse(ctx context.Context, userName string, params *ListeningActivityForUserParams, reqEditors ...RequestEditorFn) (*ListeningActivityForUserResponse, error) {
	rsp, err := c.ListeningActivityForUser(ctx, userName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListeningActivityForUserResponse(rsp)
}

// TopRecordingsForUserWithResponse request returning *TopRecordingsForUserResponse
func (c *ClientWithResponses) TopRecordingsForUserWithResponse(ctx context.Context, userName string, params *TopRecordingsForUserParams, reqEditors ...RequestEditorFn) (*TopRecordingsForUserResponse, error) {
	rsp, err := c.TopRecordingsForUser(ctx, userName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTopRecordingsForUserResponse(rsp)
}

// TopReleaseGroupsForUserWithResponse request returning *TopReleaseGroupsForUserResponse
func (c *ClientWithResponses) TopReleaseGroupsForUserWithResponse(ctx context.Context, userName string, params *TopReleaseGroupsForUserParams, reqEditors ...RequestEditorFn) (*TopReleaseGroupsForUserResponse, error) {
	rsp, err := c.TopReleaseGroupsForUser(ctx, userName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTopReleaseGroupsForUserResponse(rsp)
}

// TopReleasesForUserWithResponse request returning *TopReleasesForUserResponse
func (c *ClientWithResponses) TopReleasesForUserWithResponse(ctx context.Context, userName string, params *TopReleasesForUserParams, reqEditors ...RequestEditorFn) (*TopReleasesForUserResponse, error) {
	rsp, err := c.TopReleasesForUser(ctx, userName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTopReleasesForUserResponse(rsp)
}

// YearInMusicForUserWithResponse request returning *YearInMusicForUserResponse
func (c *ClientWithResponses) YearInMusicForUserWithResponse(ctx context.Context, userName string, year int, reqEditors ...RequestEditorFn) (*YearInMusicForUserResponse, error) {
	rsp, err := c.YearInMusicForUser(ctx, userName, year, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseYearInMusicForUserResponse(rsp)
}

// GetDumpInfoWithResponse request returning *GetDumpInfoResponse
func (c *ClientWithResponses) GetDumpInfoWithResponse(ctx context.Context, params *GetDumpInfoParams, reqEditors ...RequestEditorFn) (*GetDumpInfoResponse, error) {
	rsp, err := c.GetDumpInfo(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDumpInfoResponse(rsp)
}

// SubmitListensWithBodyWithResponse request with arbitrary body returning *SubmitListensResponse
func (c *ClientWithResponses) SubmitListensWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SubmitListensResponse, error) {
	rsp, err := c.SubmitListensWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSubmitListensResponse(rsp)
}

func (c *ClientWithResponses) SubmitListensWithResponse(ctx context.Context, body SubmitListensJSONRequestBody, reqEditors ...RequestEditorFn) (*SubmitListensResponse, error) {
	rsp, err := c.SubmitListens(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSubmitListensResponse(rsp)
}

// UnpinWithResponse request returning *UnpinResponse
func (c *ClientWithResponses) UnpinWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UnpinResponse, error) {
	rsp, err := c.Unpin(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnpinResponse(rsp)
}

// PlaylistsForUserWithResponse request returning *PlaylistsForUserResponse
func (c *ClientWithResponses) PlaylistsForUserWithResponse(ctx context.Context, playlistUserName string, params *PlaylistsForUserParams, reqEditors ...RequestEditorFn) (*PlaylistsForUserResponse, error) {
	rsp, err := c.PlaylistsForUser(ctx, playlistUserName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePlaylistsForUserResponse(rsp)
}

// PlaylistsForUserCollaboratorWithResponse request returning *PlaylistsForUserCollaboratorResponse
func (c *ClientWithResponses) PlaylistsForUserCollaboratorWithResponse(ctx context.Context, playlistUserName string, params *PlaylistsForUserCollaboratorParams, reqEditors ...RequestEditorFn) (*PlaylistsForUserCollaboratorResponse, error) {
	rsp, err := c.PlaylistsForUserCollaborator(ctx, playlistUserName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePlaylistsForUserCollaboratorResponse(rsp)
}

// PlaylistsCreatedForUserWithResponse request returning *PlaylistsCreatedForUserResponse
func (c *ClientWithResponses) PlaylistsCreatedForUserWithResponse(ctx context.Context, playlistUserName string, params *PlaylistsCreatedForUserParams, reqEditors ...RequestEditorFn) (*PlaylistsCreatedForUserResponse, error) {
	rsp, err := c.PlaylistsCreatedForUser(ctx, playlistUserName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePlaylistsCreatedForUserResponse(rsp)
}

// RecommendationPlaylistsForUserWithResponse request returning *RecommendationPlaylistsForUserResponse
func (c *ClientWithResponses) RecommendationPlaylistsForUserWithResponse(ctx context.Context, playlistUserName string, reqEditors ...RequestEditorFn) (*RecommendationPlaylistsForUserResponse, error) {
	rsp, err := c.RecommendationPlaylistsForUser(ctx, playlistUserName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRecommendationPlaylistsForUserResponse(rsp)
}

// SearchPlaylistForUserWithResponse request returning *SearchPlaylistForUserResponse
func (c *ClientWithResponses) SearchPlaylistForUserWithResponse(ctx context.Context, playlistUserName string, params *SearchPlaylistForUserParams, reqEditors ...RequestEditorFn) (*SearchPlaylistForUserResponse, error) {
	rsp, err := c.SearchPlaylistForUser(ctx, playlistUserName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchPlaylistForUserResponse(rsp)
}

// FeedEventsWithResponse request returning *FeedEventsResponse
func (c *ClientWithResponses) FeedEventsWithResponse(ctx context.Context, userName string, params *FeedEventsParams, reqEditors ...RequestEditorFn) (*FeedEventsResponse, error) {
	rsp, err := c.FeedEvents(ctx, userName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFeedEventsResponse(rsp)
}

// FeedEventsDeleteWithBodyWithResponse request with arbitrary body returning *FeedEventsDeleteResponse
func (c *ClientWithResponses) FeedEventsDeleteWithBodyWithResponse(ctx context.Context, userName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FeedEventsDeleteResponse, error) {
	rsp, err := c.FeedEventsDeleteWithBody(ctx, userName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFeedEventsDeleteResponse(rsp)
}

func (c *ClientWithResponses) FeedEventsDeleteWithResponse(ctx context.Context, userName string, body FeedEventsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*FeedEventsDeleteResponse, error) {
	rsp, err := c.FeedEventsDelete(ctx, userName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFeedEventsDeleteResponse(rsp)
}

// FeedEventsHideWithBodyWithResponse request with arbitrary body returning *FeedEventsHideResponse
func (c *ClientWithResponses) FeedEventsHideWithBodyWithResponse(ctx context.Context, userName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FeedEventsHideResponse, error) {
	rsp, err := c.FeedEventsHideWithBody(ctx, userName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFeedEventsHideResponse(rsp)
}

func (c *ClientWithResponses) FeedEventsHideWithResponse(ctx context.Context, userName string, body FeedEventsHideJSONRequestBody, reqEditors ...RequestEditorFn) (*FeedEventsHideResponse, error) {
	rsp, err := c.FeedEventsHide(ctx, userName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFeedEventsHideResponse(rsp)
}

// FeedEventsListensFollowingWithResponse request returning *FeedEventsListensFollowingResponse
func (c *ClientWithResponses) FeedEventsListensFollowingWithResponse(ctx context.Context, userName string, params *FeedEventsListensFollowingParams, reqEditors ...RequestEditorFn) (*FeedEventsListensFollowingResponse, error) {
	rsp, err := c.FeedEventsListensFollowing(ctx, userName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFeedEventsListensFollowingResponse(rsp)
}

// FeedEventsListensSimilarWithResponse request returning *FeedEventsListensSimilarResponse
func (c *ClientWithResponses) FeedEventsListensSimilarWithResponse(ctx context.Context, userName string, params *FeedEventsListensSimilarParams, reqEditors ...RequestEditorFn) (*FeedEventsListensSimilarResponse, error) {
	rsp, err := c.FeedEventsListensSimilar(ctx, userName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFeedEventsListensSimilarResponse(rsp)
}

// FeedEventsUnhideWithBodyWithResponse request with arbitrary body returning *FeedEventsUnhideResponse
func (c *ClientWithResponses) FeedEventsUnhideWithBodyWithResponse(ctx context.Context, userName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FeedEventsUnhideResponse, error) {
	rsp, err := c.FeedEventsUnhideWithBody(ctx, userName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFeedEventsUnhideResponse(rsp)
}

func (c *ClientWithResponses) FeedEventsUnhideWithResponse(ctx context.Context, userName string, body FeedEventsUnhideJSONRequestBody, reqEditors ...RequestEditorFn) (*FeedEventsUnhideResponse, error) {
	rsp, err := c.FeedEventsUnhide(ctx, userName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFeedEventsUnhideResponse(rsp)
}

// FollowWithResponse request returning *FollowResponse
func (c *ClientWithResponses) FollowWithResponse(ctx context.Context, userName string, reqEditors ...RequestEditorFn) (*FollowResponse, error) {
	rsp, err := c.Follow(ctx, userName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFollowResponse(rsp)
}

// FollowersWithResponse request returning *FollowersResponse
func (c *ClientWithResponses) FollowersWithResponse(ctx context.Context, userName string, reqEditors ...RequestEditorFn) (*FollowersResponse, error) {
	rsp, err := c.Followers(ctx, userName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFollowersResponse(rsp)
}

// FollowingWithResponse request returning *FollowingResponse
func (c *ClientWithResponses) FollowingWithResponse(ctx context.Context, userName string, reqEditors ...RequestEditorFn) (*FollowingResponse, error) {
	rsp, err := c.Following(ctx, userName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFollowingResponse(rsp)
}

// ListenCountForUserWithResponse request returning *ListenCountForUserResponse
func (c *ClientWithResponses) ListenCountForUserWithResponse(ctx context.Context, userName string, reqEditors ...RequestEditorFn) (*ListenCountForUserResponse, error) {
	rsp, err := c.ListenCountForUser(ctx, userName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListenCountForUserResponse(rsp)
}

// ListensForUserWithResponse request returning *ListensForUserResponse
func (c *ClientWithResponses) ListensForUserWithResponse(ctx context.Context, userName string, params *ListensForUserParams, reqEditors ...RequestEditorFn) (*ListensForUserResponse, error) {
	rsp, err := c.ListensForUser(ctx, userName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListensForUserResponse(rsp)
}

// PlayingNowForUserWithResponse request returning *PlayingNowForUserResponse
func (c *ClientWithResponses) PlayingNowForUserWithResponse(ctx context.Context, userName string, reqEditors ...RequestEditorFn) (*PlayingNowForUserResponse, error) {
	rsp, err := c.PlayingNowForUser(ctx, userName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePlayingNowForUserResponse(rsp)
}

// ServicesForUserWithResponse request returning *ServicesForUserResponse
func (c *ClientWithResponses) ServicesForUserWithResponse(ctx context.Context, userName string, reqEditors ...RequestEditorFn) (*ServicesForUserResponse, error) {
	rsp, err := c.ServicesForUser(ctx, userName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseServicesForUserResponse(rsp)
}

// SimilarityOfUserForUserWithResponse request returning *SimilarityOfUserForUserResponse
func (c *ClientWithResponses) SimilarityOfUserForUserWithResponse(ctx context.Context, userName string, otherUserName string, reqEditors ...RequestEditorFn) (*SimilarityOfUserForUserResponse, error) {
	rsp, err := c.SimilarityOfUserForUser(ctx, userName, otherUserName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSimilarityOfUserForUserResponse(rsp)
}

// SimilarUsersForUserWithResponse request returning *SimilarUsersForUserResponse
func (c *ClientWithResponses) SimilarUsersForUserWithResponse(ctx context.Context, userName string, reqEditors ...RequestEditorFn) (*SimilarUsersForUserResponse, error) {
	rsp, err := c.SimilarUsersForUser(ctx, userName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSimilarUsersForUserResponse(rsp)
}

// CreateNotificationWithBodyWithResponse request with arbitrary body returning *CreateNotificationResponse
func (c *ClientWithResponses) CreateNotificationWithBodyWithResponse(ctx context.Context, userName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNotificationResponse, error) {
	rsp, err := c.CreateNotificationWithBody(ctx, userName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNotificationResponse(rsp)
}

func (c *ClientWithResponses) CreateNotificationWithResponse(ctx context.Context, userName string, body CreateNotificationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNotificationResponse, error) {
	rsp, err := c.CreateNotification(ctx, userName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNotificationResponse(rsp)
}

// RecommendPersonalRecordingWithBodyWithResponse request with arbitrary body returning *RecommendPersonalRecordingResponse
func (c *ClientWithResponses) RecommendPersonalRecordingWithBodyWithResponse(ctx context.Context, userName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RecommendPersonalRecordingResponse, error) {
	rsp, err := c.RecommendPersonalRecordingWithBody(ctx, userName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRecommendPersonalRecordingResponse(rsp)
}

func (c *ClientWithResponses) RecommendPersonalRecordingWithResponse(ctx context.Context, userName string, body RecommendPersonalRecordingJSONRequestBody, reqEditors ...RequestEditorFn) (*RecommendPersonalRecordingResponse, error) {
	rsp, err := c.RecommendPersonalRecording(ctx, userName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRecommendPersonalRecordingResponse(rsp)
}

// RecommendRecordingWithBodyWithResponse request with arbitrary body returning *RecommendRecordingResponse
func (c *ClientWithResponses) RecommendRecordingWithBodyWithResponse(ctx context.Context, userName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RecommendRecordingResponse, error) {
	rsp, err := c.RecommendRecordingWithBody(ctx, userName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRecommendRecordingResponse(rsp)
}

func (c *ClientWithResponses) RecommendRecordingWithResponse(ctx context.Context, userName string, body RecommendRecordingJSONRequestBody, reqEditors ...RequestEditorFn) (*RecommendRecordingResponse, error) {
	rsp, err := c.RecommendRecording(ctx, userName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRecommendRecordingResponse(rsp)
}

// CreateReviewWithBodyWithResponse request with arbitrary body returning *CreateReviewResponse
func (c *ClientWithResponses) CreateReviewWithBodyWithResponse(ctx context.Context, userName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateReviewResponse, error) {
	rsp, err := c.CreateReviewWithBody(ctx, userName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateReviewResponse(rsp)
}

func (c *ClientWithResponses) CreateReviewWithResponse(ctx context.Context, userName string, body CreateReviewJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateReviewResponse, error) {
	rsp, err := c.CreateReview(ctx, userName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateReviewResponse(rsp)
}

// UnfollowWithResponse request returning *UnfollowResponse
func (c *ClientWithResponses) UnfollowWithResponse(ctx context.Context, userName string, reqEditors ...RequestEditorFn) (*UnfollowResponse, error) {
	rsp, err := c.Unfollow(ctx, userName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnfollowResponse(rsp)
}

// ValidateTokenWithResponse request returning *ValidateTokenResponse
func (c *ClientWithResponses) ValidateTokenWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ValidateTokenResponse, error) {
	rsp, err := c.ValidateToken(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidateTokenResponse(rsp)
}

// GetPinsWithResponse request returning *GetPinsResponse
func (c *ClientWithResponses) GetPinsWithResponse(ctx context.Context, userName string, params *GetPinsParams, reqEditors ...RequestEditorFn) (*GetPinsResponse, error) {
	rsp, err := c.GetPins(ctx, userName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPinsResponse(rsp)
}

// GetPinsCurrentWithResponse request returning *GetPinsCurrentResponse
func (c *ClientWithResponses) GetPinsCurrentWithResponse(ctx context.Context, userName string, reqEditors ...RequestEditorFn) (*GetPinsCurrentResponse, error) {
	rsp, err := c.GetPinsCurrent(ctx, userName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPinsCurrentResponse(rsp)
}

// GetPinsFollowingWithResponse request returning *GetPinsFollowingResponse
func (c *ClientWithResponses) GetPinsFollowingWithResponse(ctx context.Context, userName string, params *GetPinsFollowingParams, reqEditors ...RequestEditorFn) (*GetPinsFollowingResponse, error) {
	rsp, err := c.GetPinsFollowing(ctx, userName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPinsFollowingResponse(rsp)
}

// ParseCreateCoverArtGridForUserResponse parses an HTTP response from a CreateCoverArtGridForUserWithResponse call
func ParseCreateCoverArtGridForUserResponse(rsp *http.Response) (*CreateCoverArtGridForUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateCoverArtGridForUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateCoverArtGridResponse parses an HTTP response from a CreateCoverArtGridWithResponse call
func ParseCreateCoverArtGridResponse(rsp *http.Response) (*CreateCoverArtGridResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateCoverArtGridResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseYearInMusicResponse parses an HTTP response from a YearInMusicWithResponse call
func ParseYearInMusicResponse(rsp *http.Response) (*YearInMusicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &YearInMusicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateCustomCoverArtResponse parses an HTTP response from a CreateCustomCoverArtWithResponse call
func ParseCreateCustomCoverArtResponse(rsp *http.Response) (*CreateCustomCoverArtResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateCustomCoverArtResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRecordingRecommendationsResponse parses an HTTP response from a RecordingRecommendationsWithResponse call
func ParseRecordingRecommendationsResponse(rsp *http.Response) (*RecordingRecommendationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RecordingRecommendationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RecordingRecommendations
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteListenResponse parses an HTTP response from a DeleteListenWithResponse call
func ParseDeleteListenResponse(rsp *http.Response) (*DeleteListenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteListenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseColorResponse parses an HTTP response from a ColorWithResponse call
func ParseColorResponse(rsp *http.Response) (*ColorResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ColorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Color
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFreshReleasesResponse parses an HTTP response from a FreshReleasesWithResponse call
func ParseFreshReleasesResponse(rsp *http.Response) (*FreshReleasesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FreshReleasesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FreshReleases
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseLbRadioResponse parses an HTTP response from a LbRadioWithResponse call
func ParseLbRadioResponse(rsp *http.Response) (*LbRadioResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LbRadioResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LbRadio
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRecordingFeedbackResponse parses an HTTP response from a RecordingFeedbackWithResponse call
func ParseRecordingFeedbackResponse(rsp *http.Response) (*RecordingFeedbackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RecordingFeedbackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetFeedbackMbidResponse parses an HTTP response from a GetFeedbackMbidWithResponse call
func ParseGetFeedbackMbidResponse(rsp *http.Response) (*GetFeedbackMbidResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFeedbackMbidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FeedbackResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetFeedbackMsidResponse parses an HTTP response from a GetFeedbackMsidWithResponse call
func ParseGetFeedbackMsidResponse(rsp *http.Response) (*GetFeedbackMsidResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFeedbackMsidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FeedbackResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetFeedbackResponse parses an HTTP response from a GetFeedbackWithResponse call
func ParseGetFeedbackResponse(rsp *http.Response) (*GetFeedbackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFeedbackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FeedbackResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetFeedbackForRecordingsResponse parses an HTTP response from a GetFeedbackForRecordingsWithResponse call
func ParseGetFeedbackForRecordingsResponse(rsp *http.Response) (*GetFeedbackForRecordingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFeedbackForRecordingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FeedbackResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseLatestImportResponse parses an HTTP response from a LatestImportWithResponse call
func ParseLatestImportResponse(rsp *http.Response) (*LatestImportResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LatestImportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LatestImport
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseLbRadioRecordingsForArtistResponse parses an HTTP response from a LbRadioRecordingsForArtistWithResponse call
func ParseLbRadioRecordingsForArtistResponse(rsp *http.Response) (*LbRadioRecordingsForArtistResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LbRadioRecordingsForArtistResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LbRadioRecordingsForArtist
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseLbRadioTagsResponse parses an HTTP response from a LbRadioTagsWithResponse call
func ParseLbRadioTagsResponse(rsp *http.Response) (*LbRadioTagsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LbRadioTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LbRadioTags
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseArtistMetadataResponse parses an HTTP response from a ArtistMetadataWithResponse call
func ParseArtistMetadataResponse(rsp *http.Response) (*ArtistMetadataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArtistMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ArtistMetadata
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetManualMappingResponse parses an HTTP response from a GetManualMappingWithResponse call
func ParseGetManualMappingResponse(rsp *http.Response) (*GetManualMappingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetManualMappingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetManualMapping
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseLookupResponse parses an HTTP response from a LookupWithResponse call
func ParseLookupResponse(rsp *http.Response) (*LookupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LookupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Lookup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRecordingMetadataResponse parses an HTTP response from a RecordingMetadataWithResponse call
func ParseRecordingMetadataResponse(rsp *http.Response) (*RecordingMetadataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RecordingMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]RecordingMetadata
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReleaseGroupMetadataResponse parses an HTTP response from a ReleaseGroupMetadataWithResponse call
func ParseReleaseGroupMetadataResponse(rsp *http.Response) (*ReleaseGroupMetadataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReleaseGroupMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]ReleaseGroupMetadata
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSubmitManualMappingResponse parses an HTTP response from a SubmitManualMappingWithResponse call
func ParseSubmitManualMappingResponse(rsp *http.Response) (*SubmitManualMappingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SubmitManualMappingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePinResponse parses an HTTP response from a PinWithResponse call
func ParsePinResponse(rsp *http.Response) (*PinResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PinResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Pin200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePinDeleteResponse parses an HTTP response from a PinDeleteWithResponse call
func ParsePinDeleteResponse(rsp *http.Response) (*PinDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PinDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdatePinResponse parses an HTTP response from a UpdatePinWithResponse call
func ParseUpdatePinResponse(rsp *http.Response) (*UpdatePinResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePinResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreatePlaylistResponse parses an HTTP response from a CreatePlaylistWithResponse call
func ParseCreatePlaylistResponse(rsp *http.Response) (*CreatePlaylistResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePlaylistResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreatePlaylist200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEditPlaylistResponse parses an HTTP response from a EditPlaylistWithResponse call
func ParseEditPlaylistResponse(rsp *http.Response) (*EditPlaylistResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EditPlaylistResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSearchPlaylistsResponse parses an HTTP response from a SearchPlaylistsWithResponse call
func ParseSearchPlaylistsResponse(rsp *http.Response) (*SearchPlaylistsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchPlaylistsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Playlists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFetchPlaylistResponse parses an HTTP response from a FetchPlaylistWithResponse call
func ParseFetchPlaylistResponse(rsp *http.Response) (*FetchPlaylistResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FetchPlaylistResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreatePlaylistRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCopyPlaylistResponse parses an HTTP response from a CopyPlaylistWithResponse call
func ParseCopyPlaylistResponse(rsp *http.Response) (*CopyPlaylistResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CopyPlaylistResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeletePlaylistResponse parses an HTTP response from a DeletePlaylistWithResponse call
func ParseDeletePlaylistResponse(rsp *http.Response) (*DeletePlaylistResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePlaylistResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAppendRecordingsResponse parses an HTTP response from a AppendRecordingsWithResponse call
func ParseAppendRecordingsResponse(rsp *http.Response) (*AppendRecordingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppendRecordingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseItemDeleteResponse parses an HTTP response from a ItemDeleteWithResponse call
func ParseItemDeleteResponse(rsp *http.Response) (*ItemDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ItemDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseMoveItemResponse parses an HTTP response from a MoveItemWithResponse call
func ParseMoveItemResponse(rsp *http.Response) (*MoveItemResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MoveItemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseArtistResponse parses an HTTP response from a ArtistWithResponse call
func ParseArtistResponse(rsp *http.Response) (*ArtistResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArtistResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Artist200ResponseInner
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRecordingResponse parses an HTTP response from a RecordingWithResponse call
func ParseRecordingResponse(rsp *http.Response) (*RecordingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RecordingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Recording200ResponseInner
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReleaseResponse parses an HTTP response from a ReleaseWithResponse call
func ParseReleaseResponse(rsp *http.Response) (*ReleaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReleaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Release200ResponseInner
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReleaseGroupResponse parses an HTTP response from a ReleaseGroupWithResponse call
func ParseReleaseGroupResponse(rsp *http.Response) (*ReleaseGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReleaseGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ReleaseGroup200ResponseInner
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTopRecordingsForArtistResponse parses an HTTP response from a TopRecordingsForArtistWithResponse call
func ParseTopRecordingsForArtistResponse(rsp *http.Response) (*TopRecordingsForArtistResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TopRecordingsForArtistResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TopRecordingsForArtist
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTopReleaseGroupForArtistResponse parses an HTTP response from a TopReleaseGroupForArtistWithResponse call
func ParseTopReleaseGroupForArtistResponse(rsp *http.Response) (*TopReleaseGroupForArtistResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TopReleaseGroupForArtistResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TopReleaseGroupsForArtist
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSubmitFeedbackResponse parses an HTTP response from a SubmitFeedbackWithResponse call
func ParseSubmitFeedbackResponse(rsp *http.Response) (*SubmitFeedbackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SubmitFeedbackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteFeedbackResponse parses an HTTP response from a DeleteFeedbackWithResponse call
func ParseDeleteFeedbackResponse(rsp *http.Response) (*DeleteFeedbackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteFeedbackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFeedbackGivenByResponse parses an HTTP response from a FeedbackGivenByWithResponse call
func ParseFeedbackGivenByResponse(rsp *http.Response) (*FeedbackGivenByResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FeedbackGivenByResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FeedbackGivenBy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRecordingsFeedbackGivenByResponse parses an HTTP response from a RecordingsFeedbackGivenByWithResponse call
func ParseRecordingsFeedbackGivenByResponse(rsp *http.Response) (*RecordingsFeedbackGivenByResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RecordingsFeedbackGivenByResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RecordingsFeedbackGivenBy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSearchUsersResponse parses an HTTP response from a SearchUsersWithResponse call
func ParseSearchUsersResponse(rsp *http.Response) (*SearchUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SearchUsers
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListenersForArtistResponse parses an HTTP response from a ListenersForArtistWithResponse call
func ParseListenersForArtistResponse(rsp *http.Response) (*ListenersForArtistResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListenersForArtistResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListenersForArtist
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListenersForReleaseGroupResponse parses an HTTP response from a ListenersForReleaseGroupWithResponse call
func ParseListenersForReleaseGroupResponse(rsp *http.Response) (*ListenersForReleaseGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListenersForReleaseGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListenersForReleaseGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSitewideArtistMapResponse parses an HTTP response from a SitewideArtistMapWithResponse call
func ParseSitewideArtistMapResponse(rsp *http.Response) (*SitewideArtistMapResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SitewideArtistMapResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SitewideArtistMap
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSitewideTopArtistsResponse parses an HTTP response from a SitewideTopArtistsWithResponse call
func ParseSitewideTopArtistsResponse(rsp *http.Response) (*SitewideTopArtistsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SitewideTopArtistsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SitewideTopArtists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSitewideListeningActivityResponse parses an HTTP response from a SitewideListeningActivityWithResponse call
func ParseSitewideListeningActivityResponse(rsp *http.Response) (*SitewideListeningActivityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SitewideListeningActivityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SitewideListeningActivity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSitewideTopRecordingsResponse parses an HTTP response from a SitewideTopRecordingsWithResponse call
func ParseSitewideTopRecordingsResponse(rsp *http.Response) (*SitewideTopRecordingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SitewideTopRecordingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SitewideTopRecordings
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSitewideTopReleaseGroupsResponse parses an HTTP response from a SitewideTopReleaseGroupsWithResponse call
func ParseSitewideTopReleaseGroupsResponse(rsp *http.Response) (*SitewideTopReleaseGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SitewideTopReleaseGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SitewideTopReleaseGroups
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSitewideTopReleasesResponse parses an HTTP response from a SitewideTopReleasesWithResponse call
func ParseSitewideTopReleasesResponse(rsp *http.Response) (*SitewideTopReleasesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SitewideTopReleasesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SitewideTopReleases
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseArtistMapForUserResponse parses an HTTP response from a ArtistMapForUserWithResponse call
func ParseArtistMapForUserResponse(rsp *http.Response) (*ArtistMapForUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArtistMapForUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ArtistMapForUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTopArtistsForUserResponse parses an HTTP response from a TopArtistsForUserWithResponse call
func ParseTopArtistsForUserResponse(rsp *http.Response) (*TopArtistsForUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TopArtistsForUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TopArtistsForUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDailyActivityForUserResponse parses an HTTP response from a DailyActivityForUserWithResponse call
func ParseDailyActivityForUserResponse(rsp *http.Response) (*DailyActivityForUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DailyActivityForUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DailyActivityForUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListeningActivityForUserResponse parses an HTTP response from a ListeningActivityForUserWithResponse call
func ParseListeningActivityForUserResponse(rsp *http.Response) (*ListeningActivityForUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListeningActivityForUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListeningActivityForUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTopRecordingsForUserResponse parses an HTTP response from a TopRecordingsForUserWithResponse call
func ParseTopRecordingsForUserResponse(rsp *http.Response) (*TopRecordingsForUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TopRecordingsForUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TopRecordingsForUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTopReleaseGroupsForUserResponse parses an HTTP response from a TopReleaseGroupsForUserWithResponse call
func ParseTopReleaseGroupsForUserResponse(rsp *http.Response) (*TopReleaseGroupsForUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TopReleaseGroupsForUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TopReleaseGroupsForUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTopReleasesForUserResponse parses an HTTP response from a TopReleasesForUserWithResponse call
func ParseTopReleasesForUserResponse(rsp *http.Response) (*TopReleasesForUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TopReleasesForUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TopReleasesForUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseYearInMusicForUserResponse parses an HTTP response from a YearInMusicForUserWithResponse call
func ParseYearInMusicForUserResponse(rsp *http.Response) (*YearInMusicForUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &YearInMusicForUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest YearInMusicForUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetDumpInfoResponse parses an HTTP response from a GetDumpInfoWithResponse call
func ParseGetDumpInfoResponse(rsp *http.Response) (*GetDumpInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDumpInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetDumpInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSubmitListensResponse parses an HTTP response from a SubmitListensWithResponse call
func ParseSubmitListensResponse(rsp *http.Response) (*SubmitListensResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SubmitListensResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUnpinResponse parses an HTTP response from a UnpinWithResponse call
func ParseUnpinResponse(rsp *http.Response) (*UnpinResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnpinResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePlaylistsForUserResponse parses an HTTP response from a PlaylistsForUserWithResponse call
func ParsePlaylistsForUserResponse(rsp *http.Response) (*PlaylistsForUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PlaylistsForUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Playlists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePlaylistsForUserCollaboratorResponse parses an HTTP response from a PlaylistsForUserCollaboratorWithResponse call
func ParsePlaylistsForUserCollaboratorResponse(rsp *http.Response) (*PlaylistsForUserCollaboratorResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PlaylistsForUserCollaboratorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Playlists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePlaylistsCreatedForUserResponse parses an HTTP response from a PlaylistsCreatedForUserWithResponse call
func ParsePlaylistsCreatedForUserResponse(rsp *http.Response) (*PlaylistsCreatedForUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PlaylistsCreatedForUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Playlists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRecommendationPlaylistsForUserResponse parses an HTTP response from a RecommendationPlaylistsForUserWithResponse call
func ParseRecommendationPlaylistsForUserResponse(rsp *http.Response) (*RecommendationPlaylistsForUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RecommendationPlaylistsForUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Playlists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSearchPlaylistForUserResponse parses an HTTP response from a SearchPlaylistForUserWithResponse call
func ParseSearchPlaylistForUserResponse(rsp *http.Response) (*SearchPlaylistForUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchPlaylistForUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Playlists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFeedEventsResponse parses an HTTP response from a FeedEventsWithResponse call
func ParseFeedEventsResponse(rsp *http.Response) (*FeedEventsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FeedEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FeedEvents
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFeedEventsDeleteResponse parses an HTTP response from a FeedEventsDeleteWithResponse call
func ParseFeedEventsDeleteResponse(rsp *http.Response) (*FeedEventsDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FeedEventsDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFeedEventsHideResponse parses an HTTP response from a FeedEventsHideWithResponse call
func ParseFeedEventsHideResponse(rsp *http.Response) (*FeedEventsHideResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FeedEventsHideResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFeedEventsListensFollowingResponse parses an HTTP response from a FeedEventsListensFollowingWithResponse call
func ParseFeedEventsListensFollowingResponse(rsp *http.Response) (*FeedEventsListensFollowingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FeedEventsListensFollowingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FeedEvents
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFeedEventsListensSimilarResponse parses an HTTP response from a FeedEventsListensSimilarWithResponse call
func ParseFeedEventsListensSimilarResponse(rsp *http.Response) (*FeedEventsListensSimilarResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FeedEventsListensSimilarResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FeedEventsListensSimilar
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFeedEventsUnhideResponse parses an HTTP response from a FeedEventsUnhideWithResponse call
func ParseFeedEventsUnhideResponse(rsp *http.Response) (*FeedEventsUnhideResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FeedEventsUnhideResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFollowResponse parses an HTTP response from a FollowWithResponse call
func ParseFollowResponse(rsp *http.Response) (*FollowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FollowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFollowersResponse parses an HTTP response from a FollowersWithResponse call
func ParseFollowersResponse(rsp *http.Response) (*FollowersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FollowersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Followers
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFollowingResponse parses an HTTP response from a FollowingWithResponse call
func ParseFollowingResponse(rsp *http.Response) (*FollowingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FollowingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Following
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListenCountForUserResponse parses an HTTP response from a ListenCountForUserWithResponse call
func ParseListenCountForUserResponse(rsp *http.Response) (*ListenCountForUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListenCountForUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListenCountForUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListensForUserResponse parses an HTTP response from a ListensForUserWithResponse call
func ParseListensForUserResponse(rsp *http.Response) (*ListensForUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListensForUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListensForUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePlayingNowForUserResponse parses an HTTP response from a PlayingNowForUserWithResponse call
func ParsePlayingNowForUserResponse(rsp *http.Response) (*PlayingNowForUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PlayingNowForUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PlayingNowForUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseServicesForUserResponse parses an HTTP response from a ServicesForUserWithResponse call
func ParseServicesForUserResponse(rsp *http.Response) (*ServicesForUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ServicesForUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServicesForUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSimilarityOfUserForUserResponse parses an HTTP response from a SimilarityOfUserForUserWithResponse call
func ParseSimilarityOfUserForUserResponse(rsp *http.Response) (*SimilarityOfUserForUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SimilarityOfUserForUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SimilarityOfUserForUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSimilarUsersForUserResponse parses an HTTP response from a SimilarUsersForUserWithResponse call
func ParseSimilarUsersForUserResponse(rsp *http.Response) (*SimilarUsersForUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SimilarUsersForUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SimilarUsersForUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateNotificationResponse parses an HTTP response from a CreateNotificationWithResponse call
func ParseCreateNotificationResponse(rsp *http.Response) (*CreateNotificationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateNotificationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRecommendPersonalRecordingResponse parses an HTTP response from a RecommendPersonalRecordingWithResponse call
func ParseRecommendPersonalRecordingResponse(rsp *http.Response) (*RecommendPersonalRecordingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RecommendPersonalRecordingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRecommendRecordingResponse parses an HTTP response from a RecommendRecordingWithResponse call
func ParseRecommendRecordingResponse(rsp *http.Response) (*RecommendRecordingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RecommendRecordingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateReviewResponse parses an HTTP response from a CreateReviewWithResponse call
func ParseCreateReviewResponse(rsp *http.Response) (*CreateReviewResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateReviewResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUnfollowResponse parses an HTTP response from a UnfollowWithResponse call
func ParseUnfollowResponse(rsp *http.Response) (*UnfollowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnfollowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseValidateTokenResponse parses an HTTP response from a ValidateTokenWithResponse call
func ParseValidateTokenResponse(rsp *http.Response) (*ValidateTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ValidateTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ValidateToken
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPinsResponse parses an HTTP response from a GetPinsWithResponse call
func ParseGetPinsResponse(rsp *http.Response) (*GetPinsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPinsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetPins
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPinsCurrentResponse parses an HTTP response from a GetPinsCurrentWithResponse call
func ParseGetPinsCurrentResponse(rsp *http.Response) (*GetPinsCurrentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPinsCurrentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetPinsCurrent200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPinsFollowingResponse parses an HTTP response from a GetPinsFollowingWithResponse call
func ParseGetPinsFollowingResponse(rsp *http.Response) (*GetPinsFollowingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPinsFollowingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetPins
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}
